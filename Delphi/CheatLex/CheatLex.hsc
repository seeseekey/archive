HelpScribble project file.
12
Pynhqr _ranhq-1N5662N9
0
1
CheatLex


© 2004 by Global Technology
TRUE


1
BrowseButtons()
0
FALSE

FALSE
TRUE
16777215
0
16711680
8388736
255
FALSE
FALSE
FALSE
49
1
Scribble1
Inhaltverzeichnis




Writing



FALSE
31
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fprq2 System;}{\f4\fswiss\fcharset1 Arial;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;\red0\green128\blue0;\red0\green0\blue255;}
\deflang1031\pard\plain\f4\fs32\cf3\b Inhaltverzeichnis\plain\f4\fs32\cf1\b \{keepn\}\plain\f4\fs32\cf3\b 
\par \plain\f4\fs20\cf0\b 
\par CheatLex
\par \plain\f4\fs20\cf2\strike Was ist CheatLex?\plain\f4\fs20\cf1 \{linkID=10\}\plain\f4\fs20\cf0 
\par \plain\f4\fs20\cf2\strike Systemvoraussetzungen\plain\f4\fs20\cf1 \{linkID=20\}\plain\f4\fs20\cf0 
\par \plain\f4\fs20\cf2\strike Men\'fcs\plain\f4\fs20\cf1 \{linkID=30\}\plain\f4\fs20\cf0 
\par 
\par \plain\f4\fs20\cf0\b Die Kunst des Cheatens
\par \plain\f4\fs20\cf2\strike Vorwort\plain\f4\fs20\cf1 \{linkID=110\}\plain\f4\fs20\cf0 
\par \plain\f4\fs20\cf2\strike Einf\'fchrung\plain\f4\fs20\cf1 \{linkID=120\}\plain\f4\fs20\cf0 
\par \plain\f4\fs20\cf2\strike Was brauche ich?\plain\f4\fs20\cf1 \{linkID=125\}\plain\f4\fs20\cf0 
\par \plain\f4\fs20\cf2\strike Cheats\plain\f4\fs20\cf1 \{linkID=130\}\plain\f4\fs20\cf0 
\par \plain\f4\fs20\cf2\strike Levelcodes\plain\f4\fs20\cf1 \{linkID=140\}\plain\f4\fs20\cf0 
\par \plain\f4\fs20\cf2\strike Patches\plain\f4\fs20\cf1 \{linkID=150\}\plain\f4\fs20\cf0 
\par \plain\f4\fs20\cf2\strike Leveldateien kopieren\plain\f4\fs20\cf1 \{linkID=160\}\plain\f4\fs20\cf0 
\par \plain\f4\fs20\cf2\strike Programmdateien durchst\'f6bern\plain\f4\fs20\cf1 \{linkID=170\}\plain\f4\fs20\cf0 
\par \plain\f4\fs20\cf2\strike Bits & Bytes\plain\f4\fs20\cf1 \{linkID=180\}\plain\f4\fs20\cf0 
\par \plain\f4\fs20\cf2\strike Hexzahlen\plain\f4\fs20\cf1 \{linkID=190\}\plain\f4\fs20\cf0 
\par \plain\f4\fs20\cf2\strike Offset & Sektor\plain\f4\fs20\cf1 \{linkID=200\}\plain\f4\fs20\cf0 
\par \plain\f4\fs20\cf2\strike Spielst\'e4nde manipulieren\plain\f4\fs20\cf1 \{linkID=210\}
\par \plain\f4\fs20\cf2\strike Theorie der Decodierung\plain\f4\fs20\cf1 \{linkID=220\}\plain\f4\fs20\cf0 
\par \plain\f4\fs20\cf2\strike Subtraktions/Additions-Codieralgorithmen\plain\f4\fs20\cf1 \{linkID=230\}\plain\f4\fs20\cf0 
\par \plain\f4\fs20\cf2\strike Bitweise Codierung\plain\f4\fs20\cf1 \{linkID=240\}\plain\f4\fs20\cf0 
\par \plain\f4\fs20\cf2\strike Komprimierung\plain\f4\fs20\cf1 \{linkID=250\}\plain\f4\fs20\cf0 
\par \plain\f4\fs20\cf2\strike Der LZH-Algorithmus\plain\f4\fs20\cf1 \{linkID=260\}\plain\f4\fs20\cf0 
\par \plain\f4\fs20\cf2\strike Gepackte Dateien\plain\f4\fs20\cf1 \{linkID=270\}\plain\f4\fs20\cf0 
\par \plain\f4\fs20\cf2\strike Ausf\'fchrbare Dateien\plain\f4\fs20\cf1 \{linkID=280\}\plain\f4\fs20\cf0 
\par \plain\f4\fs20\cf2\strike Bild- & Videodateien\plain\f4\fs20\cf1 \{linkID=290\}\plain\f4\fs20 
\par }
10
Scribble10
Was ist CheatLex?
CheatLex;


a:000010
Writing



FALSE
5
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}}
{\colortbl\red0\green0\blue0;\red0\green0\blue255;\red128\green0\blue0;}
\deflang1031\pard\plain\f3\fs32\cf1\b Was ist CheatLex?\plain\f3\fs32\cf2\b \{keepn\}
\par \plain\f3\fs20 CheatLex ist ein Werkzeug, mit dem sie momentan \'fcber 400 L\'f6sungen f\'fcr viele Systeme wie z. B. C64, Amiga, Nintendo, Gamecube, Dreamcast, PC und etc in einem Programm vereint haben.
\par }
20
Scribble20
Systemvorausetzungen:



a:000020
Writing



FALSE
10
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red0\green0\blue255;\red128\green0\blue0;}
\deflang1031\pard\plain\f3\fs32\cf1\b Systemvorausetzungen:\plain\f3\fs32\cf2\b \{keepn\}
\par \plain\f3\fs20 IBM oder 100% kompatiblen PC Pentium ab 90 Mhz
\par Windows 95/98/NT (oder h\'f6her)
\par 16 MB  RAM
\par 3 MB freien Festplattenspeicher
\par Grafikkarte mit einer Aufl\'f6sung von 800 x 600 Pixel (empfohlen)
\par 100% Microsoft-kompatible Maus
\par }
30
Scribble30
Menüs
Menü;Menüs;Tools;Über;


a:000030
Writing



FALSE
72
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss Arial;}}
{\colortbl\red0\green0\blue0;\red0\green128\blue0;\red0\green0\blue255;\red128\green0\blue0;}
\deflang1031\pard\plain\f3\fs32\cf2\b Die Men\'fcs\plain\f3\fs32\cf3\b \{keepn\}\plain\f3\fs32\cf2\b 
\par \plain\f3\fs20\b 
\par \plain\f3\fs20\cf0 Datei
\par \tab \plain\f3\fs20\cf1\ul Drucken\plain\f3\fs20\cf3 \{linkID=50\}\plain\f3\fs20\cf0 
\par \tab \plain\f3\fs20\cf1\ul Drucker Setup\plain\f3\fs20\cf3 \{linkID=60\}\plain\lang1033\f4\fs20\cf3 
\par \plain\f3\fs20\cf0 \tab --------------------
\par \tab \plain\f3\fs20\cf1\strike Optionen\plain\f3\fs20\cf3 \{linkID=42\}\plain\f3\fs20\cf0 
\par \tab --------------------
\par \tab \plain\f3\fs20\cf1\ul L\'f6sung speichern unter...\plain\f3\fs20\cf3 \{linkID=33\}\plain\f3\fs20\cf0 
\par \tab --------------------
\par \tab \plain\f3\fs20\cf1\ul CheatLex beenden\plain\f3\fs20\cf3 \{linkID=70\}\plain\f3\fs20\cf0 
\par 
\par 
\par Bearbeiten
\par \plain\f3\fs20 \tab \plain\f3\fs20\cf1\ul Kopieren\plain\f3\fs20\cf3 \{linkID=80\}\plain\f3\fs20\cf0 
\par \plain\f3\fs20 \tab \plain\f3\fs20\cf0 --------------------
\par \tab \plain\f3\fs20\cf1\ul Alles markieren\plain\f3\fs20\cf3 \{linkID=90\}
\par 
\par \plain\f3\fs20\cf0 Suchen
\par \tab \plain\f3\fs20\cf1\ul Suchen\plain\f3\fs20\cf3 \{linkID=35\}\plain\f3\fs20\cf0 
\par \tab \plain\f3\fs20\cf1\ul Weitersuchen...\plain\f3\fs20\cf3 \{linkID=45\}\plain\f3\fs20\cf0 
\par 
\par 
\par System
\par \tab \plain\f3\fs20\cf1\ul Amiga\plain\f3\fs20\cf3 \{linkID=100\}\plain\f3\fs20\cf0 
\par \tab \plain\f3\fs20\cf1\ul C-64\plain\f3\fs20\cf3 \{linkID=100\}\plain\f3\fs20\cf0 
\par \tab --------------------
\par \tab \plain\f3\fs20\cf1\ul Atari Jaguar\plain\f3\fs20\cf3 \{linkID=100\}\plain\f3\fs20\cf0 
\par \tab --------------------
\par \tab \plain\f3\fs20\cf1\ul Nintendo\plain\f3\fs20\cf3 \{linkID=100\}\plain\f3\fs20\cf0 
\par \tab \plain\f3\fs20\cf1\ul SNES\plain\f3\fs20\cf3 \{linkID=100\}\plain\f3\fs20\cf0 
\par \tab \plain\f3\fs20\cf1\ul Nintendo 64\plain\f3\fs20\cf3 \{linkID=100\}\plain\f3\fs20\cf0 
\par \tab \plain\f3\fs20\cf1\ul Gamecube\plain\f3\fs20\cf3 \{linkID=100\}\plain\f3\fs20\cf0 
\par \tab \plain\f3\fs20\cf1\ul Game Boy\plain\f3\fs20\cf3 \{linkID=100\}\plain\f3\fs20\cf0 
\par \tab --------------------
\par \tab \plain\f3\fs20\cf1\ul Megadrive\plain\f3\fs20\cf3 \{linkID=100\}\plain\f3\fs20\cf0 
\par \tab \plain\f3\fs20\cf1\ul Saturn\plain\f3\fs20\cf3 \{linkID=100\}\plain\f3\fs20\cf0 
\par \tab \plain\f3\fs20\cf1\ul Dreamcast\plain\f3\fs20\cf3 \{linkID=100\}\plain\f3\fs20\cf0 
\par \tab --------------------
\par \tab \plain\f3\fs20\cf1\ul Playstation\plain\f3\fs20\cf3 \{linkID=100\}\plain\f3\fs20\cf0 
\par \tab \plain\f3\fs20\cf1\ul Playstation 2\plain\f3\fs20\cf3 \{linkID=100\}\plain\f3\fs20\cf0 
\par \tab --------------------
\par \tab \plain\f3\fs20\cf1\ul X-Box\plain\f3\fs20\cf3 \{linkID=100\}\plain\f3\fs20\cf0 
\par \tab --------------------
\par \plain\f3\fs20\cf1\ul \tab Palm Pilot\plain\f3\fs20\cf3 \{linkID=100\}\plain\f3\fs20\cf0 
\par \tab --------------------
\par \tab \plain\f3\fs20\cf1\ul PC\plain\f3\fs20\cf3 \{linkID=100\}
\par 
\par \plain\f3\fs20\cf0 Tools
\par \tab \plain\f3\fs20\cf1\ul Editor\plain\f3\fs20\cf3 \{linkID=36\}\plain\f3\fs20\cf0 
\par \tab \plain\f3\fs20\cf1\ul Rechner\plain\f3\fs20\cf3 \{linkID=38\}\plain\f3\fs20\cf0 
\par \tab \plain\f3\fs20\cf1\ul Hex Editor\plain\f3\fs20\cf3 \{linkID=39\}\plain\f3\fs20\cf0 
\par \tab \plain\f3\fs20\cf1\ul Registry Editor\plain\f3\fs20\cf3 \{linkID=37\}
\par \plain\f3\fs20\cf0 
\par Fenster
\par \tab \plain\f3\fs20\cf1\ul \'dcberlappend\plain\f3\fs20\cf3 \{linkID=55\}\plain\f3\fs20\cf0 
\par \tab \plain\f3\fs20\cf1\ul Nebeneinander\plain\f3\fs20\cf3 \{linkID=65\}\plain\f3\fs20\cf0 
\par \tab \plain\f3\fs20\cf1\ul Symbole anordnen\plain\f3\fs20\cf3 \{linkID=75\}\plain\f3\fs20\cf0 
\par \tab --------------------
\par \tab \plain\f3\fs20\cf1\ul Alle Fenster verkleinern\plain\f3\fs20\cf3 \{linkID=85\}\plain\f3\fs20\cf0 
\par \tab \plain\f3\fs20\cf1\ul Alle Fenster schlie\'dfen\plain\f3\fs20\cf3 \{linkID=95\}\plain\f3\fs20\cf0 
\par 
\par Hilfe
\par \tab \plain\f3\fs20\cf1\ul Inhalt\plain\f3\fs20\cf3 \{linkID=32\}\plain\f3\fs20\cf0 
\par \tab \plain\f3\fs20\cf1\ul Index\plain\f3\fs20\cf3 \{linkID=34\}\plain\f3\fs20\cf0 
\par \tab --------------------
\par \tab \plain\f3\fs20\cf1\ul Hilfe zur Hilfe\plain\f3\fs20\cf3 \{linkID=31\}
\par \plain\f3\fs20\cf0 \tab --------------------
\par \tab \plain\f3\fs20\cf1\ul \'dcber...\plain\f3\fs20\cf3 \{linkID=40\}\plain\f3\fs20 
\par }
31
Scribble31
Hilfe zur Hilfe




Writing



FALSE
6
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f2\fs20\cf0 Ruft die Windowshilfe zur Hilfe auf.\plain\f2\fs20\cf1 \{keepn\}\plain\f2\fs20 
\par 
\par 
\par }
32
Scribble32
Inhalt




Writing



FALSE
6
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f3\fs20\cf0 Ruft den Inhalt der CheatLex Hilfedatei auf.\plain\f3\fs20\cf1 \{keepn\}\plain\f3\fs20 
\par 
\par 
\par }
33
Scribble33
Lösung speichern unter...




Writing



FALSE
5
{\rtf1\ansi\ansicpg1252\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f3\fs20\cf0 Speichert die L\'f6sung im RTF oder TXT Format auf der Festplatte.
\par \plain\f3\fs20\cf1 \{keepn\}\plain\f3\fs20 
\par }
34
Scribble34
Index




Writing



FALSE
6
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f3\fs20\cf0 Ruft den Index der CheatLex Hilfedatei auf.\plain\f3\fs20\cf1 \{keepn\}\plain\f3\fs20 
\par 
\par 
\par }
35
Scribble35
Suchen




Writing



FALSE
6
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f2\fs20\cf0 Mit Hilfe dieser Funktion k\'f6nnen sie die L\'f6sung durchsuchen.\plain\f2\fs20\cf1 \{keepn\}\plain\f2\fs20 
\par 
\par 
\par }
36
Scribble36
Editor




Writing



FALSE
5
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f2\fs20\cf0 Ruft den Editor auf.\plain\f2\fs20\cf1 \{keepn\}\plain\f2\fs20 
\par 
\par }
37
Scribble37
Registry Editor




Writing



FALSE
6
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f3\fs20\cf0 Ruft den Registry Editor auf.\plain\f3\fs20\cf1 \{keepn\}\plain\f2\fs20 
\par 
\par 
\par }
38
Scribble38
Rechner




Writing



FALSE
6
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f3\fs20\cf0 Ruft den Rechner auf.\plain\f3\fs20\cf1 \{keepn\}\plain\f2\fs20 
\par 
\par 
\par }
39
Scribble39
Hex Editor




Writing



FALSE
6
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f3\fs20\cf0 Ruft den Hex Editor auf.\plain\f3\fs20\cf1 \{keepn\}\plain\f2\fs20 
\par 
\par 
\par }
40
Scribble40
Info Dialog




Writing



FALSE
6
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fprq2 System;}{\f4\fswiss\fcharset1 Arial;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f4\fs20\cf0 Zeigt einen Infodialog an.\plain\f4\fs20\cf1 \{keepn\}\plain\f4\fs20 
\par 
\par 
\par }
42
Scribble42
Optionen




Writing



FALSE
21
{\rtf1\ansi\ansicpg1252\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}}
{\colortbl\red0\green0\blue0;\red0\green0\blue255;}
\deflang1031\pard\plain\f3\fs32\cf1\b Optionen
\par \plain\f3\fs20\cf0 Unter Optionen k\'f6nnen sie die Einstellungen des Programmes \'e4ndern.
\par 
\par \plain\f3\fs20\cf0\b Allgemein\plain\f3\fs20\cf0 
\par Nur eine Instanz zulassen (CheatLex Neustart erforderlich):
\par Sollte diese Option aktiviert werden kann immer nur eine Instanz von CheatLex gestartet werden. Damit diese Option wirksam werden kann muss CheatLex neugestartet werden.
\par 
\par Dateierweiterung automatisch setzen:
\par Ist diese Options aktiviert so speichert werden den Dateinamen die sie vergeben unter dem Men\'fcpunkt L\'f6sung speichern unter... vergeben k\'f6nnen automatisch die Erweiterung angeh\'e4ngt.
\par 
\par In Systray minimieren:
\par Sollte dieser Men\'fcpunkt angew\'e4hlt sein, so wird CheatLex nicht in die Taskbar minimiert sondern in den Systray.
\par 
\par CheatLex Mauszeiger:
\par Ist diese Option ausgew\'e4hlt benutzt CheatLex einen anderen Mauszeiger.
\par 
\par \plain\f3\fs20\cf0\b Tools
\par \plain\f3\fs20\cf0 Unter Tools k\'f6nnen sie die Pfade der Tools einstellen.\plain\f3\fs20 
\par }
45
Scribble45
Weitersuchen




Writing



FALSE
6
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f2\fs20 Sucht das Wort das Sie im Suchen Dialog eingegeben haben.\plain\f2\fs20\cf1 \{keepn\}\plain\f2\fs20 
\par 
\par 
\par }
50
Scribble50
Drucken




Writing



FALSE
5
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f3\fs20\cf0 Druckt die aktuell angew\'e4hlte L\'f6sung.\plain\f3\fs20\cf1 \{keepn\}\plain\f3\fs20 
\par 
\par }
55
Scribble55
Überlappend




Writing



FALSE
6
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f2\fs20\cf0 Ordnet die Fenster \'fcberlappend an.\plain\f2\fs20\cf1 \{keepn\}\plain\f2\fs20 
\par 
\par 
\par }
60
Scribble60
Drucker Setup




Writing



FALSE
4
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f3\fs20\cf0 Hier k\'f6nnen sie den Drucker konfigurieren.\plain\f3\fs20\cf1 \{keepn\}\plain\f3\fs20 
\par }
65
Scribble65
Nebeneinander




Writing



FALSE
6
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f3\fs20\cf0 Ordnet die Fenster nebeneinander an.\plain\f3\fs20\cf1 \{keepn\}\plain\f2\fs20 
\par 
\par 
\par }
70
Scribble70
CheatLex beenden




Writing



FALSE
5
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f3\fs20\cf0 Hiermit beenden sie CheatLex nach einer Sicherheitsabfrage.\plain\f3\fs20\cf1 \{keepn\}\plain\f3\fs20 
\par 
\par }
75
Scribble75
Symbole anordnen




Writing



FALSE
5
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f3\fs20\cf0 Ordnet die Symbole an.\plain\f3\fs20\cf1 \{keepn\}\plain\f3\fs20 
\par 
\par }
80
Scribble80
Kopieren




Writing



FALSE
4
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f3\fs20\cf0 Der markierte Text wird in die Zwischenablage kopiert.\plain\f3\fs20\cf1 \{keepn\}\plain\f3\fs20 
\par }
85
Scribble85
Alle Fenster verkleinern




Writing



FALSE
4
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f2\fs20\cf0 Verkleinert alle Fenster.\plain\f2\fs20\cf1 \{keepn\}\plain\f2\fs20 
\par }
90
Scribble90
Alles markieren




Writing



FALSE
4
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f3\fs20\cf0 Der gesamte Text in der aktuellen L\'f6sungen wird komplett markiert.\plain\f3\fs20\cf1 \{keepn\}\plain\f3\fs20 
\par }
95
Scribble95
Alle Fenster schließen




Writing



FALSE
6
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f2\fs20\cf0 Schlie\'dft alle Fenster.\plain\f2\fs20\cf1 \{keepn\}\plain\f2\fs20 
\par 
\par 
\par }
100
Scribble100
System




Writing



FALSE
4
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f3\fs20\cf0 Eine Auswahliste mit L\'f6sungen f\'fcr das aktuell angew\'e4hlte System wird angezeigt.\plain\f3\fs20\cf1 \{keepn\}\plain\f3\fs20 
\par }
110
Scribble110
Vorwort



b:000010
Writing



FALSE
11
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fprq2 System;}{\f4\fswiss\fcharset1 Arial;}}
{\colortbl\red0\green0\blue0;\red0\green0\blue255;\red128\green0\blue0;}
\deflang1031\pard\plain\f4\fs32\cf1\b Vorwort\{keepn\}
\par \plain\f4\fs20\cf0 Immer wieder scheitern sie in ihrem neuchsten Ego Shooter.
\par Sie besitzen schon wieder zu wenig Geld bei Sim City.
\par 
\par Sollte es Ihnen so oder \'e4hnlich ergehen, so haben Sie zwei M\'f6glichkeiten:
\par 
\par 1. Die L\'f6sung ist in CheatLex bereits enthalten.
\par 2. Sollte dies nicht zutreffen so ist dieser Abschnitt der Hilfe genau das richtige f\'fcr sie.\plain\f4\fs20 
\par }
120
Scribble120
Einführung
Geduld;Taschenrechner;to cheat;


b:000020
Writing



FALSE
23
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fprq2 System;}{\f4\fswiss\fcharset1 Arial;}}
{\colortbl\red0\green0\blue0;\red0\green0\blue255;\red128\green0\blue0;}
\deflang1031\pard\plain\f4\fs32\cf1\b Einf\'fchrung\plain\f4\fs32\cf2 \{keepn\}
\par \plain\f4\fs20\cf0 Das Wort Cheaten ist vom englischen Verb to cheat abgeleitet was soviel bedeutet wie mogeln oder betr\'fcgen. Das Gebiet des Cheaten genannt, ist sehr vielf\'e4lltig. Diese Hilfedatei versucht alle legalen Bereiche abzudecken. Nat\'fcrlich ist nicht  vollkommen auszuschlie\'dfen, da\'df Ihnen hiermit illegale Handlungen erleichtert werden, aber bitte beachten Sie, da\'df Sie diese Hilfedatei nicht verwenden d\'fcrfen f\'fcr:
\par 
\par \pard\li200\fi-200\tx200{\*\pn\pnlvlblt\pnf1\pnindent200{\pntxtb\'b7}}\plain\f4\fs20\cf0 {\pntext\f1\'b7\tab}das Aussp\'e4hen von Daten, die nicht f\'fcr Sie bestimmt und gegen unberechtigten Zugang besonders gesichert sind(\'a7202a StGB)
\par {\pntext\f1\'b7\tab}Computersabotage(\'a7303b StGB)
\par {\pntext\f1\'b7\tab}das Entfernen von Kopierschutzcodes aus Raubkopien
\par {\pntext\f1\'b7\tab}sonstige strafbare Handlungen
\par \pard\plain\f4\fs20\cf0 
\par \pard\qc\plain\f4\fs20\cf0\b Hinweis:
\par Der Autor \'fcbernimmt nicht die Verantwortung f\'fcr evtl. Sch\'e4den, die durch Anwendung dieses Wissens entstehen k\'f6nnten.\plain\f4\fs20\cf0 
\par \pard\plain\f4\fs20\cf0 
\par Um alle Schritte in dieser Anleitung nachzuvollziehend brauchen sie folgende Programme:
\par 
\par \pard\li200\fi-200\tx200{\*\pn\pnlvlblt\pnf1\pnindent200{\pntxtb\'b7}}\plain\f4\fs20\cf0 {\pntext\f1\'b7\tab}einen Hexeditor
\par {\pntext\f1\'b7\tab}einen Textbetrachter mit umfangreicher Suchfunktion
\par {\pntext\f1\'b7\tab}einen Taschenrechner
\par \pard\plain\f4\fs20\cf0 
\par Als Hexeditor ist der Hex Workshop zu empfehlen, der allerdings nach einer Testphase f\'fcr 30$ registriert werden muss. Einen sehr guten Textbetrachter ist die beim Norton Commander mitgelieferte WPVIEW.EXE. Als Taschenrechner reicht es wenn sie denn Windowsrechner benutzen.
\par 
\par Was sie auf alle f\'e4lle mitbringen sollten ist Geduld.\plain\f4\fs20 
\par }
125
Scribble125
Was brauche ich?
Hexeditor;Taschenrechner;Textbetrachter;UNP;


b:000030
Writing



FALSE
22
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss Arial;}{\f5\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;\red0\green0\blue255;}
\deflang1031\pard\plain\f3\fs32\cf2\b Was brauche ich?\plain\f3\fs32\cf1\b \{keepn\}\plain\f3\fs32\cf2\b 
\par \plain\f4\fs20\cf0 Zum Cheaten brauchen sie:
\par 
\par \pard\li200\fi-200\tx200{\*\pn\pnlvlblt\pnf1\pnindent200{\pntxtb\'b7}}\plain\f4\fs20\cf0 {\pntext\f1\'b7\tab}einen Hexeditor
\par {\pntext\f1\'b7\tab}den Windows Taschenrechner
\par {\pntext\f1\'b7\tab}einen Textbetrachter
\par {\pntext\f1\'b7\tab}ein Entpackprogramm (z.B. UNP)
\par \pard\tx200\plain\f4\fs20\cf0 
\par \pard\plain\f4\fs20\cf0 Der Hexeditor
\par Ein Hexeditor ist ein Programm, mit dem jede beliebige Datei auf bin\'e4rer Ebende ver\'e4ndern k\'f6nnen, indem sie in Dateien nach Heximalfolgen suchen und einzelne Speicherzellen ver\'e4ndern. \'c4ltere Bezeichnungen dieser Werkzeuge sind Disk-Editor und Disk-Monitor. Emfehlenswert sind Hexeditoren mit Umrechnungsfunktionen. 
\par 
\par Der Windows Taschenrechner
\par Den Windows Taschenrechner ben\'f6tigen sie, um Dezimale Zahlen in das Heximale Format umzurechnen. Ist in ihrem Hexeditor bereit eine Umrechnungsfunktion enthalten, dann ist der Windows Taschenrechner \'fcberfl\'fcssig. 
\par 
\par Der Textbetrachter
\par Den Textbetrachter ben\'f6tigen sie um z.B. Passw\'f6rter aus den Dateien eines Spieles zulesen. Ein guter Textbetrachter sollte keine Datenmengenbeschr\'e4nkung aufweisen, die Datei automatisch umbrechen, ANSI und ASCII darstellen k\'f6nnen, eine umfangreiche Suchfunktion mit zahlreichen Optionen besitzen, die aktuelle Zeile/Spalte anzeigen und die Datei oder Bruchst\'fccke der Datei ausdrucken k\'f6nnen. 
\par 
\par Das Entpackprogramm
\par \'c4ltere Programmdateien sind h\'e4ufig mit einem EXE-Packer komprimiert worden, der den Platzbedarf etwa um die H\'e4lfte reduziert. Die bekanntesten dieser Packer, allesamt frei kopierbar hei\'dfen LZEXE, PKLite, Diet und Tiny. Bei Dateien die mit solchen EXE-Packern gepackt worden sind, lassen sich Levelcodes nicht mehr einfach per Textbetrachter auslesen. Diese Dateien m\'fcssen erst entpackt werden. Mit dem Programm UNP lassen sich all diese Dateien entpacken und somit in den Urzustand zur\'fcckversetzen. UNP wird automatisch mit CheatLex installiert. Sie finden es im CheatLex Verzeichnes im Ordner UNP.\plain\f3\fs20\cf0 
\par }
130
Scribble130
Cheats
cheat;Cheats;debug;extra;free;freeze;god;hint;immortal;invisible;invulnerable;items;Kommandozeilenparameter;mega;modus;money;more;power;super;Tastenkombinationen;undead;unsichtbar;unsterblich;


b:000040
Writing



FALSE
38
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red0\green0\blue255;}
\deflang1031\pard\plain\f3\fs32\cf1\b Cheats\{keepn\}
\par \plain\f3\fs20 
\par Da Spieleprogrammierer nicht jedesmal wenn sie in Level 64 einen Fehler entdeckt haben, das gesamte Spiel nocheinmal bis zu diesem Level spielen haben sie Cheats eingebaut. Da reicht das dr\'fccken einer bestimmten Tastenfolge und schon ist man unverwundbar, voll ausger\'fcstet. 
\par 
\par Suche:
\par 
\par Man nehme sich wieder einmal einen Textbetrachter und sehe sich alle "*.exe"-Dateien an. (Manchmal sind die ausf\'fchrbaren Dateien auch in anderen Dateitypen versteckt, ein klares Erkennungszeichen f\'fcr solche Dateien bieten die 2 Buchstaben MZ am Anfang.) Jetzt sollte man nach folgenden signifikanten W\'f6rtern suchen:
\par 
\par \plain\f3\fs20\b Allgemein:\plain\f3\fs20 
\par "debug", "hint", "cheat", "modus" 
\par 
\par \plain\f3\fs20\b Unsterblichkeit:\plain\f3\fs20 
\par "god", "unsterblich", "immortal", "invulnerable", "undead"
\par 
\par \plain\f3\fs20\b Sonstiges:\plain\f3\fs20 
\par "unsichtbar", "invisible", "super", "mega", "freeze", "power", "extra", "money", "items", "free", "invincible", "full", "more"
\par 
\par Sollte man eines dieser Worte in den Spieldateien gefunden haben so kann man mit hoher Warscheinlichkeit davon ausgehen dass es im betrffenden Spiel einen Cheat gibt.
\par 
\par Zur Aktivierung gibt folgende M\'f6glichkeiten:
\par 
\par Kommandozeilenparameter findet man \'fcber signifikante Zeichen, wie "-" oder "/"
\par 
\par Eingabe:
\par Dabei werden W\'f6rter w\'e4hrend des Spiels eingegeben. Beliebt sind obig aufgez\'e4hlte W\'f6rter.
\par 
\par Tastenkombinationen:
\par Wer viel Spa\'df beim Probieren hat, sollte diverse Kombinationen, wie [CTRL]+[ALT]+[BACK] ausprobieren. Die Erfolgschancen sind allerdings gering.
\par 
\par Sonstiges:
\par Joystickbewegungen, bestimmte Mausklicks und \'e4hnliches sind \'e4u\'dferst schwer und nur \'fcber Probieren herauszufinden.
\par 
\par Hinweise:
\par 
\par Die Gro\'df- und Kleinschreibung sollte streng beachtet werden. Findet man W\'f6rter, wie "DEBUG", so probiert man am besten "debug" und [SHIFT]+"debug". Die Aktivierungsm\'f6glichkeiten sind im allgemeinen sehr schwer auffindbar. Aus diesem Grund sollte man nicht viel Zeit beim Probieren vergeuden, sondern andere Wege zur Unsterblichkeit finden..
\par }
140
Scribble140
Levelcodes
Levelcodes;Paßwörtern;Zugriffscode;


b:000050
Writing



FALSE
5
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;\red0\green0\blue255;}
\deflang1031\pard\plain\f2\fs32\cf2\b Levelcodes\plain\f2\fs32\cf1\b \{keepn\}\plain\f2\fs32\cf2\b 
\par \plain\f2\fs20\cf0 Mit Hilfe von Pa\'dfw\'f6rtern soll erzwungen werden, da\'df sie ihr Spiel zun\'e4chst in der Reihenfolge >>abarbeiten<<, wie es von den Programmierern vorgesehen wurde. Haben sie einen Level beendet, erhalten sie den Zugriffscode, mit dessen Hilfe sie den Level direkt anw\'e4hlen k\'f6nnen.\plain\f2\fs20 
\par }
150
Scribble150
Patches
cheat;Datendateien;Patches;Spielstände;


b:000060
Writing



FALSE
7
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red0\green0\blue255;\red128\green0\blue0;}
\deflang1031\pard\plain\f3\fs32\cf1\b Patches\plain\f3\fs32\cf2\b \{keepn\}\plain\f3\fs32\cf1\b 
\par \plain\f3\fs20\cf0 Wer nicht aufgeben will, weil kein eingebauter Cheat zur Verf\'fcgung steht, der fa\'dft entweder die Programmdatei oder abgespeicherte Spielst\'e4nde ins Auge. Wenn ein Spielstand einer Wirtschaftssimulation abgespeichert wird, dann findet man in diesem Spielstand garantiert die Information die das momentane Guthaben im betrefenden Spiel speichert. Mit ein bischen Ahnung in Punkto Hexzahlen und Co. kann man den Stand des Guthabens sprunghaft anheben. Weitaus schwieriger ist das patchen von Programmcode. Dazu m\'fcssen sie \'fcber exzellente Kentnisse in Assembler und warscheinlich auch C verf\'fcgen.
\par 
\par Ein Spiel liegt in der Regel in einer Menge Programm- und Datendateien vor, neben der EXE Datei, mit der das Spiel aufgerufen wird, sind das etwa Level-, Grafik-, Sound- und Konfigurationsdateien. An vielen Stellen warten Cheatm\'f6glichkeiten.\plain\f3\fs20 
\par }
160
Scribble160
Leveldateien kopieren
kopieren;Leveldateien;Orginalzustand;Patches;


b:000070
Writing



FALSE
5
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red0\green0\blue255;\red128\green0\blue0;}
\deflang1031\pard\plain\f3\fs32\cf1\b Leveldateien kopieren\plain\f3\fs32\cf2\b \{keepn\}\plain\f3\fs32\cf1\b 
\par \plain\f3\fs20\cf0 Wenn ein Spiel zehn Level hat, und sie finden zehn Dateien mit den Namen level01.dat bis level10.dat so liegt der Gedanke nah, da\'df jede dieser Dateien einen kompletten Level enth\'e4lt und sie durch das ersetzen der level01.dat durch die level10.dat zuerst Level 10 spielen k\'f6nnen. Sie sollten jedoch bevor sie die Datei ersetzen eine Sicherheitskopie von der zu ersetzenden Datei anfertigen damit sie im Notfall den Orginalzustand des Spieles wieder herstellen k\'f6nnen.\plain\f3\fs20 
\par }
170
Scribble170
Programmdateien durchstöbern
durchstöbern;Patches;Programmdateien;Textbetrachter;


b:000080
Writing



FALSE
15
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fprq2 System;}{\f4\fswiss\fcharset1 Arial;}}
{\colortbl\red0\green0\blue0;\red0\green0\blue255;\red0\green128\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f4\fs32\cf1\b Programmdateien durchst\'f6bern\plain\f4\fs32\cf3\b \{keepn\}\plain\f4\fs32\cf1\b 
\par \plain\f4\fs20\cf0 Nehmen wir einmal an sie kommen in ihrem neusten Adventure nicht weiter weil sie die Schl\'fcsselkarte nicht gefunden haben. Wollen Sie nicht auf publizierte Komplettl\'f6sungen warten, so haben Sie die M\'f6glichkeit, sich selber auf der Suche nach Hinweisen zu begeben:
\par 
\par \pard\li200\fi-200\tx200{\*\pn\pnlvlblt\pnf1\pnindent200{\pntxtb\'b7}}\plain\f4\fs20\cf0 {\pntext\f1\'b7\tab}Suchen Sie zuerst in der "*.exe"-Datei nach einem Schl\'fcsselwort(z.B. Schl\'fcsselkarte, Schl\'fcssel usw.)
\par {\pntext\f1\'b7\tab}
\par {\pntext\f1\'b7\tab}Sollten sie in der *.exe Datei nichts gefunden haben versuchen sie es in naheliegenden Dateien (*.dat, *.txt)
\par {\pntext\f1\'b7\tab}
\par {\pntext\f1\'b7\tab}Sollten Sie das Wort jetzt immer noch nicht gefunden haben, so ist der Text codiert, wobei die \plain\f4\fs20\cf2\strike Decodierung\plain\f4\fs20\cf3 \{linkID=220\}\plain\f4\fs20\cf0  sehr schwer sein sollte, da einfach nicht gen\'fcgend Anhaltspunkte vorhanden sind.
\par {\pntext\f1\'b7\tab}
\par \pard\plain\f4\fs20\cf0 Nachdem sie das Wort gefunden haben, sollten sie sich die W\'f6rter neben dem Schl\'fcsselwort merken, denn sie k\'f6nnten ein Anhaltspunkt daf\'fcr sein wo sich die Schl\'fcsselkarte befindet.
\par 
\par In den Programmdateien befinden sich manchmal auch die unverschl\'fcsselten Levelcodes, undokomentierte Kommandozeilenparameter usw.\plain\f4\fs20 
\par }
180
Scribble180
Bits & Bytes
Bit;Bits;Byte;


b:000090
Writing



FALSE
11
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}}
{\colortbl\red0\green0\blue0;\red0\green0\blue255;\red128\green0\blue0;}
\deflang1031\pard\plain\f2\fs32\cf1\b Bits & Bytes\plain\f2\fs20\cf2\b \{keepn\}\plain\f2\fs20\cf1\b 
\par \plain\f2\fs20\cf0 Ein Bit kann zwei zust\'e4nde annehmen, Null oder Eins. Ein Bit allein sagt nicht viel aus, aber je mehr Bits kombiniert werden, desto mehr M\'f6glichkeiten lassen sich vereinbaren. Jedes neue Bit verdoppelt die Anzahl der schon vorhandenen Zeichen. Etwas mathematischer betrachtet, k\'f6nnen n Bit 2 hoch n Zust\'e4nde darstellen.
\par 
\par Rein technisch ist ein Bit nur ein Schaltzustand,der nach belieben interpretiert wird. Kaum vorstellbar, aber jedes Spiel ist nichts weiter als eine schier endlose Folge von Bits also von Nullen und Einsen.
\par 
\par \plain\f2\fs20 Freilich macht es nicht unbedingt Spa\'df, mit endlosen Kolonen von Nullen und Einsen zu Hantieren. Deswegen fa\'dft man 8 Bit zu einer gr\'f6\'dferen Informationseinheit zusammen, dem Byte. Es kann einen Wert von 000000000 bis 11111111 annehmen bzw. Werte von 0 bis 255. Ein Byte ist die kleinste Speichereinheit, die ein PC lesen und schreiben kann. Deswegen sagt man, der Speicher ist in Zellen unterteilt, die je ein Byte Kapazit\'e4t besitzen. Ein Byte enth\'e4lt entweder einen Teil des Programmcodes oder Daten, z. B. die Anzahl der Leben, die noch \'fcbrig sind, oder einen Buchstaben.
\par 
\par Daf\'fcr mu\'dfsten nat\'fcrlich Vereibarungen geschaffen werden. Die Intel-Prozessoren und die Chips der Mitbewerber verstehen einen einheitlichen Befehlssatz. Und f\'fcr den Text hat man eine Normierung geschaffen, den sogenannten ASCII Code (American Standard Code for Information Interchange). Die Bitfolge 01000001 wurde z. B. der Buchstabe A zugewiesen.\plain\f3\fs20 
\par }
190
Scribble190
Hexzahlen
Dezimalsystem;Hexzahlen;Offset;Sektor;Spielstände;


b:000100
Writing



FALSE
46
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss Arial;}}
{\colortbl\red0\green0\blue0;\red0\green0\blue255;}
\deflang1031\pard\plain\f3\fs32\cf1\b Hexzahlen\plain\f3\fs20\cf0 \{keepn\}
\par Im Dezimalsystem steht eine Ziffer f\'fcr einen der zehn Werte zwischen Null und Neun. Im Bin\'e4rsystem gibt es nur zwei Ziffern. Ansonsten ist die Z\'e4hlung im Bin\'e4rsystem nicht ungew\'f6hnlich: 0, 1, 10, 11, 100, 101, 110, 111. Bin\'e4rzahlen lassen sich in Dezimalzahlen umwandeln und umgekehrt. Der ASCII-Code f\'fcr den Buchstaben A besitzt die Bitfolge 01000001, hat so den dezimalen Wert 65. Viele TAschenrechner, auch der Windows beiliegende, k\'f6nnen zwischen beiden Formaten konvertieren.
\par 
\par \plain\f4\fs20\cf0 Dabei taucht ein Sch\'f6nheitsfehler auf: Das Dezimalsystem, mit dem wir aufgewachsen sind, ist nicht ideal als Ersatz f\'fcr bin\'e4re Zahlen. Nehmen wir 4 Bit, die 16 Zust\'e4nde speichern k\'f6nnen: 
\par 
\par 0000 entspricht der 00 im Dezimalsystem 
\par 0001 entspricht der 01 im Dezimalsystem 
\par 0010 entspricht der 02 im Dezimalsystem 
\par 0011 entspricht der 03 im Dezimalsystem 
\par 0100 entspricht der 04 im Dezimalsystem 
\par 0101 entspricht der 05 im Dezimalsystem 
\par 0110 entspricht der 06 im Dezimalsystem 
\par 0111 entspricht der 07 im Dezimalsystem 
\par 1000 entspricht der 08 im Dezimalsystem 
\par 1001 entspricht der 09 im Dezimalsystem 
\par 1010 entspricht der 10 im Dezimalsystem 
\par 1011 entspricht der 11 im Dezimalsystem 
\par 1100 entspricht der 12 im Dezimalsystem 
\par 1101 entspricht der 13 im Dezimalsystem 
\par 1110 entspricht der 14 im Dezimalsystem 
\par 1111 entspricht der 15 im Dezimalsystem 
\par 
\par Um die Dezimalzahlen von 0 bis 9 bin\'e4r darzustellen, ben\'f6tigen sie 4 Bit. Es geht aber nicht genau auf: 3 Bit reichen f\'fcr nur 8 Dezimalzahlen, 4 Bit aber bereits f\'fcr 16 Zahlen. 3 Bit sind damit zu wenig, um 4 Bit sind eine Verschwendung, weil die Bin\'e4rzahlen 1010 bis 1111 ungenutzt bleiben.
\par 
\par Deshalb f\'fchrte man ein Zahlensystem ein, das au\'dfer den Ziffern 0 bis 9 noch die restlichen sechs Stellen ausf\'fcllt, die zur Darstellung einer 4-Bit-Zahl notwendig sind. Und mangels geeigneter Ziffernsymbole nahm man die Buchstaben A bis F. Diese Hexadezimalzahlen z\'e4hlen nach der 9 von A bis F, dann folgt die 10. Nach 19 folgt 1A und nach 1F kommt die 20:
\par 
\par 0 .. 9, A, B .. F, 10, 11 .. 19, 1A, 1B .. 1F, 20 .. 99, 9A .. 9F, A0 .. FF, 100, 101 .. 109, 10A ...
\par 
\par Mit Hilfe der Hexzahlen k\'f6nnen sie den Spielstand ihrer neusten Wirtschaftssimulation so ver\'e4ndern das sie anstatt 10000 $ auf der Bank nun 1000000 $ auf der Bank liegen.
\par 
\par Mit Hilfe des Windowstaschenrechners k\'f6nnen Dezimalzahlen in Hexzahlen umgerechnet werden. Mitunter stellt man Hexzahlen eine oder mehrere Nullen voran. Das hat nur optische Gr\'fcnde, die Hexzahl 0123 hat den gleichen Wert wie 123.
\par 
\par Wichtige Umrechnungen:
\par 
\par Hexadezimal\tab Dezimal\tab 
\par 00.00.00.0A \tab 10 \tab 
\par 00.00.00.63 \tab 99 \tab 
\par 00.00.00.64 \tab 100 \tab 
\par 00.00.00.FF \tab 255 (der h\'f6chste Wert f\'fcr ein Byte) \tab 
\par 00.00.7F.FF \tab 32767 \tab 
\par 00.00.FF.FF \tab 65535 (der h\'f6chste Wert f\'fcr zwei Byte) \tab 
\par 00.FF.FF.FF \tab 16.777.215 (der h\'f6chste Wert f\'fcr drei Byte) \tab 
\par FF.FF.FF.FF \tab 4.294.697.295 (der h\'f6chste Wert f\'fcr vier Byte)\plain\f3\fs20 
\par }
200
Scribble200
Offset & Sektor
Einheit;Offset;Sektor;


b:000110
Writing



FALSE
7
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\froman Times New Roman;}{\f5\fswiss Arial;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;\red0\green0\blue255;}
\deflang1031\pard\plain\f2\fs32\cf2\b Offset & Sektor\plain\f2\fs32\cf1\b \{keepn\}\plain\f2\fs20 
\par \plain\f5\fs20 Eine Datei ist eine Folge von Bytes oder 8 Bit. Je 4 Bit entsprechen einer Hexadezimalziffer. Also l\'e4\'dft sich ein Byte durch ein Paar aus Hexadezimalziffern darstellen. Damit sich bestimmte Bytes ansprechen lassen, werden sie nummeriert. Die Z\'e4hlung beginnt mit 0, das erste Byte liegt also an der Adresse oder Offset 0. Wenn in einer Datei das siebte Byte gefragt ist, meint man Offset 6, weil die Z\'e4hlung mit 0 beginnt.
\par 
\par Manchmal taucht der Begriff Sektor auf. Ein Sektor ist eine Einheit von 512 (Dezimal-) Byte. Sektor 5, Offset 45 ist also nur eine Umschreibung f\'fcr Offset 5 * 512 + 45 = 2605, wobei bei dieser Notation fast immer Dezimalzahlen verwendet werden.\plain\f3\fs20 
\par }
210
Scribble210
Spielstände manipulieren
manipulieren;Spielstände;


b:000120
Writing



FALSE
14
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss Arial;}{\f4\fswiss\fcharset1 Arial;}}
{\colortbl\red0\green0\blue0;\red0\green0\blue255;\red128\green0\blue0;}
\deflang1031\pard\plain\f4\fs32\cf1\b Spielst\'e4nde manipulieren\plain\f4\fs32\cf2\b \{keepn\}\plain\f4\fs32\cf1\b 
\par \plain\f3\fs20\cf0 Nehmen wir nun an sie m\'f6chten irgenteinen Wert in einem Spiel ver\'e4ndern. Die Vorgehensweise hierf\'fcr ist immer gleich:
\par 
\par 1. Sie merken sich den Wert, den sie ver\'e4ndern wollen, z. B. den Geldbetrag.
\par 2. Sie speichern den Spielstand ab.
\par 3. Sie \'f6ffnen die Spielstandsdatei mit einem Hex-Editor.
\par 4. Sie rechnen den Wert in eine Hexzahl um. (Windows Taschenrechner)
\par 5. Sie suchen den Hexwert im Spielstand.
\par 6. Sie \'e4ndern den Hexwert nach ihren Vorstellungen an.
\par 7. Sie speichern ab.
\par 8. Sie laden im Spiel den ge\'e4nderten Spielstand.\plain\f4\fs20 
\par }
220
Scribble220
Theorie der Decodierung
Cäsar;Decodierung;


b:000130
Writing



FALSE
24
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}}
{\colortbl\red0\green0\blue0;\red0\green0\blue255;\red128\green0\blue0;}
\deflang1031\pard\plain\f3\fs32\cf1\b Theorie der Decodierung\plain\f3\fs32\cf2\b \{keepn\}\plain\f3\fs20\cf0 
\par Die Decodierung ist eines der schwierigsten Bereiche des Cheatens, denn es gibt unendlich viele M\'f6glichkeiten, einen Text zu verschl\'fcsseln. Aufgrund dieser Komplexit\'e4t m\'f6chte ich mich auf die gebr\'e4uchlichsten Codierungsarten beschr\'e4nken. Sollte man tiefer in die Materie der Codierung eindringen wollen, so sollte man sich entsprechende B\'fccher besorgen. F\'fcr die meisten Programme ist dies nicht notwendig, da sie meist mit den einfachsten Methoden zu knacken" sind. Das wichtigste ist, da\'df man gen\'fcgend Anhaltspunkte besitzt, um die richtige Methode zu finden. Sie sollten mindestens f\'fcnf verschiedene W\'f6rter und ihre codierten Entsprechungen f\'fcr das Auffinden eines Codieralgorithmus besitzen. 
\par 
\par Am besten ist es, wenn Sie selbst bestimmen k\'f6nnen, was codiert wird. Fangen Sie in dem Fall mit dem Wort "A", dann "AA" an. Sollte sich der 1. Buchstabe nicht ver\'e4ndern, so haben Sie erst einmal die Gewi\'dfheit, da\'df die Codierung nicht von der L\'e4nge des Wortes abh\'e4ngt. Probieren Sie nun "BA" und sollte sich der zweite Buchstabe nicht ver\'e4ndern, so wissen Sie au\'dferdem, da\'df die Buchstaben sich nicht gegenseitig kausal bedingen. In diesem Fall brauchen Sie sich nur noch eine Tabelle anzulegen, in der die Entsprechungen jedes Buchstabens stehen. 
\par 
\par Wenn komplette Dateien verschl\'fcsselt sind, so k\'f6nnen Sie den Grad der Verschl\'fcsselung sehr leicht mit einem Packprogramm absch\'e4tzen. Hier eine kurze \'dcbersicht:
\par 
\par Komprimierrate\tab Verschl\'fcsselung\tab \tab \tab \tab \tab \tab Decodierungschancen
\par 
\par 50-100%\tab einfaches XOR oder Addition\tab \tab \tab \tab \tab sehr gut
\par 
\par 20-50%\tab \tab Verkn\'fcpfung von XOR und Addition\tab \tab \tab \tab mittelm\'e4\'dfig
\par 
\par 10-20%\tab \tab komplexer Algorithmus (meist mit Division & Multiplikation)\tab schlecht
\par 
\par 0-10%\tab \tab polynomer/hochkomplexer Algorithmus oder ein Packer\tab \tab probieren Sie 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab einen der 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab handels\'fcblichen LZH-
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab Algorithmen oder 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab vergessen Sie's 
\par \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab einfach.
\par }
230
Scribble230
Subtraktions/Additions-Codieralgorithmen
Addition;Codieralgorithmen;Decodierung;Subtraktion;


b:000140
Writing



FALSE
7
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}}
{\colortbl\red0\green0\blue0;\red0\green0\blue255;\red128\green0\blue0;}
\deflang1031\pard\plain\f3\fs32\cf1\b Subtraktions/Additions-Codieralgorithmen\plain\f3\fs32\cf2\b \{keepn\}\plain\f3\fs32\cf1\b 
\par \plain\f3\fs20\cf0 Dieser Codieralgorithmus ist der einfachste, den es gibt. Er wurde schon von C\'e4sar angewendet und geht wie folgt:
\par 
\par Jedes Zeichen entspricht einer Zahl (Entsprechungen entnehmen Sie bitte einer ASCII-Tabelle). So ist zum Beispiel ein "A" die 65. Bei der Codierung durch Subtraktion wird die Zahl um eine konstante Zahl verkleinert und durch Addition um diese vergr\'f6\'dfert. So entsteht bei der Addition eines A(65) mit 2 ein C. Das einzige Problem ist - wie bei jedem Zahlenbereich - der \'dcberlauf. Subtrahiert man zum Beispiel vom Zeichen mit der Nummer 1 eine 2 so entsteht eine -1. Da aber eine negative Zahl im Byte-Bereich(0..255) nicht existiert, geht man bei Bereichs\'fcberschreitungen wie folgt vor: Man addiere oder subtrahiere so lange 256 bis das codierte Zeichen im Zahlenbereich liegt. Bei -1 mu\'df man zum Beispiel 256 addieren und schon erh\'e4lt man 255.\plain\f3\fs20 
\par }
240
Scribble240
Bitweise Codierung
AND;bitweise Codierung;Codierung;Decodierung;OR;XOR;


b:000150
Writing



FALSE
75
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;\red0\green0\blue255;}
\deflang1031\pard\plain\f3\fs32\cf2\b Bitweise Codierung\plain\f3\fs32\cf1\b \{keepn\}\plain\f3\fs32\cf2\b 
\par \plain\f3\fs20\cf0 Bei der bitweisen Codierung ben\'f6tigt man die bin\'e4re Zahlendarstellung. Dies kann man ziemlich einfach mit dem Windowstaschenrechner realisieren:
\par 
\par Beispiel: Zeichen A = 65 dezimal = 1000001 bin\'e4r
\par 
\par Zur Codierung verkn\'fcpft man diese bin\'e4re Zahl \'fcber eine logische Operation mit einer Konstanten:
\par 
\par XOR
\par 
\par Diese Operation ist die beliebteste, da Sie bei eine eineindeutige Abbildung liefert und bei zweimaiger Anwendung den Ausgangszustand wieder herbeif\'fchrt.
\par 
\par Regeln:
\par 
\par 0 XOR 0 = 0
\par 0 XOR 1 = 1
\par 1 XOR 0 = 1
\par 1 XOR 1 = 0
\par 
\par Beispiel:
\par 
\par \tab 01000001 (65)
\par     XOR\tab 00110001 (49)
\par          =\tab 01110000 (112)
\par 
\par OR
\par 
\par Diese Operation ist nicht eineindeutig, sie wird aber bei Pa\'dfw\'f6rtern, die man nicht zu decodieren braucht, verwandt.
\par 
\par Regeln:
\par 
\par 0 OR 0 = 0
\par 0 OR 1 = 1
\par 1 OR 0 = 1
\par 1 OR 1 = 1
\par 
\par Beispiel:
\par 
\par \tab 01000001 (65)
\par     OR\tab 00110001 (49)
\par          =\tab 01110001 (113)
\par 
\par AND
\par 
\par Diese Operation ist nicht eineindeutig und wird sehr selten verwandt:
\par 
\par Regeln:
\par 
\par 0 AND 0 = 0
\par 0 AND 1 = 0
\par 1 AND 0 = 0
\par 1 AND 1 = 1
\par 
\par Beispiel:
\par 
\par \tab 01000001 (65)
\par     AND\tab 00110001 (49)
\par          =\tab 00000001 (1)
\par 
\par 
\par NOT
\par 
\par Diese Operation ist eineindeutig, l\'e4\'dft aber keine Verschl\'fcsselung mit Konstanten zu und wird somit nur in Kombination mit anderen Verschl\'fcsselungsmethoden (wie Subtraktion/Addition).
\par 
\par Regeln:
\par 
\par NOT 0 = 1
\par NOT 1 = 0
\par 
\par Beispiel:
\par 
\par     NOT\tab 01000001 (65)
\par          =\tab 10111110 (190)\plain\f3\fs20 
\par }
250
Scribble250
Komprimierung
Codierung;Decodierung;Komprimieralgorithmen;Komprimierung;


b:000160
Writing



FALSE
7
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;\red0\green0\blue255;}
\deflang1031\pard\plain\f3\fs32\cf2\b Komprimierung\plain\f3\fs32\cf1\b \{keepn\}\plain\f3\fs32\cf2\b 
\par \plain\f3\fs20\cf0 Die sicherste Art der Codierung ist es, eine unbekannte Komprimiermethode anzuwenden. Diese Methoden sind so komplex, da\'df man, selbst wenn man das Programm disassemblieren sollte (ist \'fcbrigens verboten) nie den Decodieralgorithmus herausfinden wird. Da aber keine Softwarefirma es sich leisten kann eigene Komprimieralgorithmen zu entwicklen, werden meistens die handels\'fcblichen verwandt. 
\par 
\par Wie man bestimmte Komprimiermethoden aufsp\'fcrt, wird im Kapitel gepackte Dateien beschreiben. Bei Windows-Programmen wird \'fcbrigens meist das Microsoft (R) File Compression Utility verwandt. Diese Dateien kann man mit den Microsoft (R) Diamond Extraction Tool entpacken ("extract.exe" bei Windows mit dabei). Dann gibt es aber noch Komprimieralgorithmen, die nicht kommerziell vertrieben werden, sondern als Source-Codes erh\'e4ltlich sind. Diese findet man vor allem bei Shareware-Programmen an. \plain\f3\fs20 
\par }
260
Scribble260
Der LZH-Algorithmus
Codierung;Decodierung;Komprimieralgorithmen;Komprimierung;


b:000170
Writing



FALSE
1904
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss Arial;}{\f5\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;\red0\green0\blue255;\red255\green0\blue0;}
\deflang1031\pard\plain\f3\fs32\cf2\b Der LZH-Algorithmus\plain\f3\fs32\cf1\b \{keepn\}\plain\f3\fs32\cf2\b 
\par \plain\f3\fs20\cf0 Der LZH Komprimieralgorithmus, ist ein Komprimieralgorithmus der in Turbo Pascal geschrieben wurde. Man findet ihn vor allem bei Shareware-Programmen an. Das Programm besteht aus zwei getrennten Dateien, der Unit "lzh.pas" und dem Testprogramm "lzhtest.pas". Sie sind durch einen roten Querbalken getrennt. Das compilierte Programm finden sie im CheatLex Verzeichnis im Ordner LZHTEST.
\par 
\par \{lzh.pas\}
\par 
\par Unit LZH;
\par 
\par  \{$A+,B-,D-,E-,F-,I+,L-,N-,O-,R-,S-,V-\}
\par 
\par (*
\par  * LZHUF.C English version 1.0
\par  * Based on Japanese version 29-NOV-1988
\par  * LZSS coded by Haruhiko OKUMURA
\par  * Adaptive Huffman Coding coded by Haruyasu YOSHIZAKI
\par  * Edited and translated to English by Kenji RIKITAKE
\par  * Translated from C to Turbo Pascal by Douglas Webb   2/18/91
\par 
\par  *    Update and bug correction of TP version 4/29/91 (Sorry!!)
\par  *)
\par 
\par \{
\par      This Unit allows the user to commpress data using a combination of
\par    LZSS Compression and adaptive Huffman coding, or conversely to deCompress
\par    data that was previously Compressed by this Unit.
\par 
\par      There are a number of options as to where the data being Compressed/
\par    deCompressed is coming from/going to.
\par 
\par     In fact it requires that you pass the "LZHPack" Procedure 2 procedural
\par 
\par   parameter of Type 'GetProcType' and 'PutProcType' (declared below) which
\par   will accept 3 parameters and act in every way like a 'BlockRead'/'BlockWrite'
\par   Procedure call. Your 'GetProcType' Procedure should return the data
\par   to be Compressed, and Your 'PutProcType' Procedure should do something with
\par   the Compressed data (ie., put it in a File).  In Case you need to know (and
\par   you do if you want to deCompress this data again) the number of Bytes in the
\par   Compressed data (original, not Compressed size) is returned in 'Bytes_Written'.
\par 
\par   GetBytesProc = Procedure(Var DTA; NBytes:Word; Var Bytes_Got : Word);
\par   
\par   DTA is the start of a memory location where the inFormation returned should
\par   be.  NBytes is the number of Bytes requested.  The actual number of Bytes
\par   returned must be passed in Bytes_Got (if there is no more data then 0
\par   should be returned).
\par 
\par   PutBytesProc = Procedure(Var DTA; NBytes:Word; Var Bytes_Got : Word);
\par 
\par   As above except instead of asking For data the Procedure is dumping out
\par 
\par   Compressed data, do somthing With it.
\par 
\par 
\par     "LZHUnPack" is basically the same thing in reverse.  It requires
\par   procedural parameters of Type 'PutProcType'/'GetProcType' which
\par   will act as above.  'GetProcType' must retrieve data Compressed using
\par   "LZHPack" (above) and feed it to the unpacking routine as requested.
\par   'PutProcType' must accept the deCompressed data and do something
\par   withit.  You must also pass in the original size of the deCompressed data,
\par   failure to do so will have adverse results.
\par 
\par      Don't Forget that as procedural parameters the 'GetProcType'/'PutProcType'
\par   Procedures must be Compiled in the 'F+' state to avoid a catastrophe.
\par 
\par 
\par 
\par \}
\par 
\par \{ note: All the large data structures For these routines are allocated when
\par   needed from the heap, and deallocated when finished.  So when not in use
\par   memory requirements are minimal.  However, this Unit Uses about 34K of
\par   heap space, and 400 Bytes of stack when in use. \}
\par 
\par 
\par Interface
\par 
\par Type
\par 
\par 
\par   PutBytesProc = Procedure(Var DTA; NBytes : Word; Var Bytes_Put : Word);
\par 
\par   GetBytesProc = Procedure(Var DTA; NBytes : Word; Var Bytes_Got : Word);
\par 
\par 
\par 
\par Procedure LZHPack(Var Bytes_Written : LongInt;
\par                       GetBytes : GetBytesProc;
\par                       PutBytes : PutBytesProc);
\par 
\par 
\par Procedure LZHUnpack(TextSize : LongInt;
\par                     GetBytes : GetBytesProc;
\par                     PutBytes : PutBytesProc);
\par 
\par 
\par Implementation
\par 
\par Const
\par   Exit_OK = 0;
\par   Exit_FAILED = 1;
\par 
\par   \{ LZSS Parameters \}
\par   N = 4096;                            \{ Size of String buffer \}
\par 
\par   F = 60;                              \{ Size of look-ahead buffer \}
\par   THRESHOLD = 2;
\par   NUL = N;                             \{ end of tree's node  \}
\par 
\par   \{ Huffman coding parameters \}
\par   N_Char = (256 - THRESHOLD + F);
\par 
\par   \{ Character code (:= 0..N_Char-1) \}
\par   T = (N_Char * 2 - 1);                \{ Size of table \}
\par 
\par 
\par   R = (T - 1);                         \{ root position \}
\par 
\par   \{ update when cumulative frequency \}
\par   \{ reaches to this value \}
\par   MAX_FREQ = $8000;
\par 
\par \{
\par  * Tables For encoding/decoding upper 6 bits of
\par 
\par  * sliding dictionary Pointer
\par  \}
\par 
\par   \{ encoder table \}
\par   p_len : Array[0..63] of Byte =
\par   ($03, $04, $04, $04, $05, $05, $05, $05,
\par    $05, $05, $05, $05, $06, $06, $06, $06,
\par    $06, $06, $06, $06, $06, $06, $06, $06,
\par    $07, $07, $07, $07, $07, $07, $07, $07,
\par    $07, $07, $07, $07, $07, $07, $07, $07,
\par    $07, $07, $07, $07, $07, $07, $07, $07,
\par    $08, $08, $08, $08, $08, $08, $08, $08,
\par    $08, $08, $08, $08, $08, $08, $08, $08);
\par 
\par   p_code : Array[0..63] of Byte =
\par 
\par   ($00, $20, $30, $40, $50, $58, $60, $68,
\par    $70, $78, $80, $88, $90, $94, $98, $9C,
\par    $A0, $A4, $A8, $AC, $B0, $B4, $B8, $BC,
\par    $C0, $C2, $C4, $C6, $C8, $CA, $CC, $CE,
\par    $D0, $D2, $D4, $D6, $D8, $DA, $DC, $DE,
\par    $E0, $E2, $E4, $E6, $E8, $EA, $EC, $EE,
\par    $F0, $F1, $F2, $F3, $F4, $F5, $F6, $F7,
\par    $F8, $F9, $FA, $FB, $FC, $FD, $FE, $FF);
\par 
\par   \{ decoder table \}
\par   d_code : Array[0..255] of Byte =
\par   ($00, $00, $00, $00, $00, $00, $00, $00,
\par    $00, $00, $00, $00, $00, $00, $00, $00,
\par 
\par    $00, $00, $00, $00, $00, $00, $00, $00,
\par    $00, $00, $00, $00, $00, $00, $00, $00,
\par    $01, $01, $01, $01, $01, $01, $01, $01,
\par    $01, $01, $01, $01, $01, $01, $01, $01,
\par    $02, $02, $02, $02, $02, $02, $02, $02,
\par    $02, $02, $02, $02, $02, $02, $02, $02,
\par    $03, $03, $03, $03, $03, $03, $03, $03,
\par    $03, $03, $03, $03, $03, $03, $03, $03,
\par    $04, $04, $04, $04, $04, $04, $04, $04,
\par    $05, $05, $05, $05, $05, $05, $05, $05,
\par    $06, $06, $06, $06, $06, $06, $06, $06,
\par 
\par    $07, $07, $07, $07, $07, $07, $07, $07,
\par    $08, $08, $08, $08, $08, $08, $08, $08,
\par    $09, $09, $09, $09, $09, $09, $09, $09,
\par    $0A, $0A, $0A, $0A, $0A, $0A, $0A, $0A,
\par    $0B, $0B, $0B, $0B, $0B, $0B, $0B, $0B,
\par    $0C, $0C, $0C, $0C, $0D, $0D, $0D, $0D,
\par    $0E, $0E, $0E, $0E, $0F, $0F, $0F, $0F,
\par    $10, $10, $10, $10, $11, $11, $11, $11,
\par    $12, $12, $12, $12, $13, $13, $13, $13,
\par    $14, $14, $14, $14, $15, $15, $15, $15,
\par    $16, $16, $16, $16, $17, $17, $17, $17,
\par 
\par    $18, $18, $19, $19, $1A, $1A, $1B, $1B,
\par    $1C, $1C, $1D, $1D, $1E, $1E, $1F, $1F,
\par    $20, $20, $21, $21, $22, $22, $23, $23,
\par    $24, $24, $25, $25, $26, $26, $27, $27,
\par    $28, $28, $29, $29, $2A, $2A, $2B, $2B,
\par    $2C, $2C, $2D, $2D, $2E, $2E, $2F, $2F,
\par    $30, $31, $32, $33, $34, $35, $36, $37,
\par    $38, $39, $3A, $3B, $3C, $3D, $3E, $3F);
\par 
\par   d_len : Array[0..255] of Byte =
\par   ($03, $03, $03, $03, $03, $03, $03, $03,
\par    $03, $03, $03, $03, $03, $03, $03, $03,
\par 
\par    $03, $03, $03, $03, $03, $03, $03, $03,
\par    $03, $03, $03, $03, $03, $03, $03, $03,
\par    $04, $04, $04, $04, $04, $04, $04, $04,
\par    $04, $04, $04, $04, $04, $04, $04, $04,
\par    $04, $04, $04, $04, $04, $04, $04, $04,
\par    $04, $04, $04, $04, $04, $04, $04, $04,
\par    $04, $04, $04, $04, $04, $04, $04, $04,
\par    $04, $04, $04, $04, $04, $04, $04, $04,
\par    $05, $05, $05, $05, $05, $05, $05, $05,
\par    $05, $05, $05, $05, $05, $05, $05, $05,
\par    $05, $05, $05, $05, $05, $05, $05, $05,
\par 
\par    $05, $05, $05, $05, $05, $05, $05, $05,
\par    $05, $05, $05, $05, $05, $05, $05, $05,
\par    $05, $05, $05, $05, $05, $05, $05, $05,
\par    $05, $05, $05, $05, $05, $05, $05, $05,
\par    $05, $05, $05, $05, $05, $05, $05, $05,
\par    $06, $06, $06, $06, $06, $06, $06, $06,
\par    $06, $06, $06, $06, $06, $06, $06, $06,
\par    $06, $06, $06, $06, $06, $06, $06, $06,
\par    $06, $06, $06, $06, $06, $06, $06, $06,
\par    $06, $06, $06, $06, $06, $06, $06, $06,
\par    $06, $06, $06, $06, $06, $06, $06, $06,
\par 
\par    $07, $07, $07, $07, $07, $07, $07, $07,
\par    $07, $07, $07, $07, $07, $07, $07, $07,
\par    $07, $07, $07, $07, $07, $07, $07, $07,
\par    $07, $07, $07, $07, $07, $07, $07, $07,
\par    $07, $07, $07, $07, $07, $07, $07, $07,
\par    $07, $07, $07, $07, $07, $07, $07, $07,
\par    $08, $08, $08, $08, $08, $08, $08, $08,
\par    $08, $08, $08, $08, $08, $08, $08, $08);
\par 
\par   getbuf : Word = 0;
\par   getlen : Byte = 0;
\par   putlen : Byte = 0;
\par   putbuf : Word = 0;
\par   TextSize : LongInt = 0;
\par   codesize : LongInt = 0;
\par 
\par   printcount : LongInt = 0;
\par   match_position : Integer = 0;
\par   match_length : Integer = 0;
\par 
\par 
\par Type
\par   FreqType = Array[0..T] of Word;
\par   FreqPtr = ^FreqType;
\par   PntrType = Array[0..pred(T + N_Char)] of Integer;
\par   pntrPtr = ^PntrType;
\par   SonType = Array[0..pred(T)] of Integer;
\par   SonPtr = ^SonType;
\par   TextBufType = Array[0..N + F - 2] of Byte;
\par   TBufPtr = ^TextBufType;
\par   WordRay = Array[0..N] of Integer;
\par   WordRayPtr = ^WordRay;
\par   BWordRay = Array[0..N + 256] of Integer;
\par 
\par   BWordRayPtr = ^BWordRay;
\par 
\par Var
\par   Text_buf : TBufPtr;
\par   lson, dad : WordRayPtr;
\par   rson : BWordRayPtr;
\par   freq : FreqPtr;                      \{ cumulative freq table \}
\par 
\par \{
\par  * pointing parent nodes.
\par  * area [T..(T + N_Char - 1)] are Pointers For leaves
\par  \}
\par   prnt : pntrPtr;
\par 
\par   \{ pointing children nodes (son[], son[] + 1)\}
\par   son : SonPtr;
\par 
\par 
\par   Procedure InitTree;                  \{ Initializing tree \}
\par   Var
\par     i : Integer;
\par   begin
\par     For i := N + 1 to N + 256 do
\par 
\par       rson^[i] := NUL;                 \{ root \}
\par     For i := 0 to N do
\par       dad^[i] := NUL;                  \{ node \}
\par   end;
\par 
\par 
\par   Procedure InsertNode(R : Integer);   \{ Inserting node to the tree \}
\par   Var
\par     tmp, i, p, cmp : Integer;
\par     key : TBufPtr;
\par     c : Word;
\par   begin
\par     cmp := 1;
\par     key := @Text_buf^[R];
\par     p := succ(N) + key^[0];
\par     rson^[R] := NUL;
\par     lson^[R] := NUL;
\par     match_length := 0;
\par     While match_length < F do
\par       begin
\par         if (cmp >= 0) then
\par 
\par           begin
\par             if (rson^[p] <> NUL) then
\par               p := rson^[p]
\par             else
\par               begin
\par                 rson^[p] := R;
\par                 dad^[R] := p;
\par                 Exit;
\par               end;
\par           end
\par         else
\par           begin
\par             if (lson^[p] <> NUL) then
\par               p := lson^[p]
\par             else
\par               begin
\par                 lson^[p] := R;
\par                 dad^[R] := p;
\par                 Exit;
\par               end;
\par 
\par           end;
\par         i := 0;
\par         cmp := 0;
\par         While (i < F) and (cmp = 0) do
\par           begin
\par             inc(i);
\par             cmp := key^[i] - Text_buf^[p + i];
\par           end;
\par         if (i > THRESHOLD) then
\par           begin
\par             tmp := pred((R - p) and pred(N));
\par             if (i > match_length) then
\par               begin
\par                 match_position := tmp;
\par                 match_length := i;
\par               end;
\par             if (match_length < F) and (i = match_length) then
\par 
\par               begin
\par                 c := tmp;
\par                 if (c < match_position) then
\par                   match_position := c;
\par               end;
\par           end;
\par       end;                             \{ While True do \}
\par     dad^[R] := dad^[p];
\par     lson^[R] := lson^[p];
\par     rson^[R] := rson^[p];
\par     dad^[lson^[p]] := R;
\par     dad^[rson^[p]] := R;
\par     if (rson^[dad^[p]] = p) then
\par       rson^[dad^[p]] := R
\par     else
\par       lson^[dad^[p]] := R;
\par     dad^[p] := NUL;                    \{ remove p \}
\par 
\par   end;
\par 
\par 
\par   Procedure DeleteNode(p : Integer);   \{ Deleting node from the tree \}
\par   Var
\par     q : Integer;
\par   begin
\par     if (dad^[p] = NUL) then
\par       Exit;                            \{ unregistered \}
\par     if (rson^[p] = NUL) then
\par       q := lson^[p]
\par     else if (lson^[p] = NUL) then
\par       q := rson^[p]
\par     else
\par       begin
\par         q := lson^[p];
\par         if (rson^[q] <> NUL) then
\par           begin
\par             Repeat
\par               q := rson^[q];
\par             Until (rson^[q] = NUL);
\par 
\par             rson^[dad^[q]] := lson^[q];
\par             dad^[lson^[q]] := dad^[q];
\par             lson^[q] := lson^[p];
\par             dad^[lson^[p]] := q;
\par           end;
\par         rson^[q] := rson^[p];
\par         dad^[rson^[p]] := q;
\par       end;
\par     dad^[q] := dad^[p];
\par     if (rson^[dad^[p]] = p) then
\par       rson^[dad^[p]] := q
\par     else
\par       lson^[dad^[p]] := q;
\par     dad^[p] := NUL;
\par   end;
\par 
\par   \{ Huffman coding parameters \}
\par 
\par   Function GetBit(GetBytes : GetBytesProc) : Integer; \{ get one bit \}
\par 
\par   Var
\par     i : Byte;
\par     i2 : Integer;
\par     result : Word;
\par   begin
\par     While (getlen <= 8) do
\par       begin
\par         GetBytes(i, 1, result);
\par         if result = 1 then
\par           i2 := i
\par         else i2 := 0;
\par         getbuf := getbuf or (i2 shl (8 - getlen));
\par         inc(getlen, 8);
\par       end;
\par     i2 := getbuf;
\par     getbuf := getbuf shl 1;
\par     dec(getlen);
\par     GetBit := Integer((i2 < 0));
\par   end;
\par 
\par 
\par   Function GetByte(GetBytes : GetBytesProc) : Integer; \{ get a Byte \}
\par 
\par   Var
\par     j : Byte;
\par     i, result : Word;
\par   begin
\par     While (getlen <= 8) do
\par       begin
\par         GetBytes(j, 1, result);
\par         if result = 1 then
\par           i := j
\par         else
\par           i := 0;
\par         getbuf := getbuf or (i shl (8 - getlen));
\par         inc(getlen, 8);
\par       end;
\par     i := getbuf;
\par     getbuf := getbuf shl 8;
\par     dec(getlen, 8);
\par     GetByte := Integer(i shr 8);
\par   end;
\par 
\par 
\par   Procedure Putcode(l : Integer; c : Word;
\par                     PutBytes : PutBytesProc); \{ output c bits \}
\par 
\par   Var
\par     Temp : Byte;
\par     Got : Word;
\par   begin
\par     putbuf := putbuf or (c shr putlen);
\par     inc(putlen, l);
\par     if (putlen >= 8) then
\par       begin
\par         Temp := putbuf shr 8;
\par         PutBytes(Temp, 1, Got);
\par         dec(putlen, 8);
\par         if (putlen >= 8) then
\par           begin
\par             Temp := lo(putbuf);
\par             PutBytes(Temp, 1, Got);
\par             inc(codesize, 2);
\par             dec(putlen, 8);
\par             putbuf := c shl (l - putlen);
\par           end
\par 
\par         else
\par           begin
\par             putbuf := putbuf shl 8;
\par             inc(codesize);
\par           end;
\par       end;
\par   end;
\par 
\par 
\par   \{ initialize freq tree \}
\par 
\par   Procedure StartHuff;
\par   Var
\par     i, j : Integer;
\par   begin
\par     For i := 0 to pred(N_Char) do
\par       begin
\par         freq^[i] := 1;
\par         son^[i] := i + T;
\par         prnt^[i + T] := i;
\par       end;
\par     i := 0;
\par     j := N_Char;
\par     While (j <= R) do
\par       begin
\par         freq^[j] := freq^[i] + freq^[i + 1];
\par 
\par         son^[j] := i;
\par         prnt^[i] := j;
\par         prnt^[i + 1] := j;
\par         inc(i, 2);
\par         inc(j);
\par       end;
\par     freq^[T] := $ffff;
\par     prnt^[R] := 0;
\par   end;
\par 
\par 
\par   \{ reConstruct freq tree \}
\par 
\par   Procedure reConst;
\par   Var
\par     i, j, k, tmp : Integer;
\par     F, l : Word;
\par   begin
\par     \{ halven cumulative freq For leaf nodes \}
\par     j := 0;
\par     For i := 0 to pred(T) do
\par       begin
\par         if (son^[i] >= T) then
\par           begin
\par             freq^[j] := succ(freq^[i]) div 2; \{@@ Bug Fix MOD -> div @@\}
\par 
\par             son^[j] := son^[i];
\par             inc(j);
\par           end;
\par       end;
\par     \{ make a tree : first, connect children nodes \}
\par     i := 0;
\par     j := N_Char;
\par     While (j < T) do
\par       begin
\par         k := succ(i);
\par         F := freq^[i] + freq^[k];
\par         freq^[j] := F;
\par         k := pred(j);
\par         While F < freq^[k] do
\par           dec(k);
\par         inc(k);
\par         l := (j - k) shl 1;
\par         tmp := succ(k);
\par         move(freq^[k], freq^[tmp], l);
\par         freq^[k] := F;
\par 
\par         move(son^[k], son^[tmp], l);
\par         son^[k] := i;
\par         inc(i, 2);
\par         inc(j);
\par       end;
\par     \{ connect parent nodes \}
\par     For i := 0 to pred(T) do
\par       begin
\par         k := son^[i];
\par         if (k >= T) then
\par           begin
\par             prnt^[k] := i;
\par           end
\par         else
\par           begin
\par             prnt^[k] := i;
\par             prnt^[succ(k)] := i;
\par           end;
\par       end;
\par   end;
\par 
\par 
\par   \{ update freq tree \}
\par 
\par   Procedure update(c : Integer);
\par 
\par   Var
\par     i, j, k, l : Integer;
\par   begin
\par     if (freq^[R] = MAX_FREQ) then
\par       begin
\par         reConst;
\par       end;
\par     c := prnt^[c + T];
\par     Repeat
\par       inc(freq^[c]);
\par       k := freq^[c];
\par       \{ swap nodes to keep the tree freq-ordered \}
\par       l := succ(c);
\par       if (k > freq^[l]) then
\par         begin
\par           While (k > freq^[l]) do
\par             inc(l);
\par           dec(l);
\par           freq^[c] := freq^[l];
\par           freq^[l] := k;
\par           i := son^[c];
\par 
\par           prnt^[i] := l;
\par           if (i < T) then prnt^[succ(i)] := l;
\par           j := son^[l];
\par           son^[l] := i;
\par           prnt^[j] := c;
\par           if (j < T) then prnt^[succ(j)] := c;
\par           son^[c] := j;
\par           c := l;
\par         end;
\par       c := prnt^[c];
\par     Until (c = 0);                     \{ Repeat it Until reaching the root \}
\par   end;
\par 
\par 
\par Var
\par   code, len : Word;
\par 
\par   Procedure EncodeChar(c : Word; PutBytes : PutBytesProc);
\par   Var
\par     i : Word;
\par 
\par     j, k : Integer;
\par   begin
\par     i := 0;
\par     j := 0;
\par     k := prnt^[c + T];
\par     \{ search connections from leaf node to the root \}
\par     Repeat
\par       i := i shr 1;
\par  \{
\par         if node's address is odd, output 1
\par         else output 0
\par         \}
\par       if Boolean(k and 1) then inc(i, $8000);
\par       inc(j);
\par       k := prnt^[k];
\par     Until (k = R);
\par     Putcode(j, i, PutBytes);
\par     code := i;
\par     len := j;
\par     update(c);
\par   end;
\par 
\par 
\par   Procedure EncodePosition(c : Word; PutBytes : PutBytesProc);
\par 
\par   Var
\par     i, j : Word;
\par   begin
\par     \{ output upper 6 bits With encoding \}
\par     i := c shr 6;
\par     j := p_code[i];
\par     Putcode(p_len[i], j shl 8, PutBytes);
\par     \{ output lower 6 bits directly \}
\par     Putcode(6, (c and $3f) shl 10, PutBytes);
\par   end;
\par 
\par 
\par   Procedure Encodeend(PutBytes : PutBytesProc);
\par   Var
\par     Temp : Byte;
\par     Got : Word;
\par   begin
\par     if Boolean(putlen) then
\par       begin
\par         Temp := lo(putbuf shr 8);
\par         PutBytes(Temp, 1, Got);
\par         inc(codesize);
\par 
\par       end;
\par   end;
\par 
\par 
\par   Function DecodeChar(GetBytes : GetBytesProc) : Integer;
\par   Var
\par     c : Word;
\par   begin
\par     c := son^[R];
\par     \{
\par      * start searching tree from the root to leaves.
\par      * choose node #(son[]) if input bit = 0
\par      * else choose #(son[]+1) (input bit = 1)
\par     \}
\par     While (c < T) do
\par       begin
\par         c := c + GetBit(GetBytes);
\par         c := son^[c];
\par       end;
\par     c := c - T;
\par     update(c);
\par     DecodeChar := Integer(c);
\par   end;
\par 
\par 
\par   Function DecodePosition(GetBytes : GetBytesProc) : Word;
\par 
\par   Var
\par     i, j, c : Word;
\par   begin
\par     \{ decode upper 6 bits from given table \}
\par     i := GetByte(GetBytes);
\par     c := Word(d_code[i] shl 6);
\par     j := d_len[i];
\par     \{ input lower 6 bits directly \}
\par     dec(j, 2);
\par     While j <> 0 do
\par       begin
\par         i := (i shl 1) + GetBit(GetBytes);
\par         dec(j);
\par       end;
\par     DecodePosition := c or i and $3f;
\par   end;
\par 
\par 
\par   \{ Compression \}
\par 
\par   Procedure InitLZH;
\par   begin
\par     getbuf := 0;
\par     getlen := 0;
\par     putlen := 0;
\par 
\par     putbuf := 0;
\par     TextSize := 0;
\par     codesize := 0;
\par     printcount := 0;
\par     match_position := 0;
\par     match_length := 0;
\par     new(lson);
\par     new(dad);
\par     new(rson);
\par     new(Text_buf);
\par     new(freq);
\par     new(prnt);
\par     new(son);
\par   end;
\par 
\par 
\par   Procedure endLZH;
\par   begin
\par     dispose(son);
\par     dispose(prnt);
\par     dispose(freq);
\par     dispose(Text_buf);
\par     dispose(rson);
\par     dispose(dad);
\par     dispose(lson);
\par   end;
\par 
\par 
\par   Procedure LZHPack(Var Bytes_Written : LongInt;
\par 
\par                         GetBytes : GetBytesProc;
\par                         PutBytes : PutBytesProc);
\par   Var
\par     ct : Byte;
\par     i, len, R, s, last_match_length : Integer;
\par     Got : Word;
\par   begin
\par     InitLZH;
\par     TextSize := 0;                     \{ rewind and rescan \}
\par     StartHuff;
\par     InitTree;
\par     s := 0;
\par     R := N - F;
\par     fillChar(Text_buf^[0], R, ' ');
\par     len := 0;
\par     Got := 1;
\par     While (len < F) and (Got <> 0) do
\par       begin
\par         GetBytes(ct, 1, Got);
\par 
\par         if Got <> 0 then
\par           begin
\par             Text_buf^[R + len] := ct;
\par             inc(len);
\par           end;
\par       end;
\par     TextSize := len;
\par     For i := 1 to F do
\par       InsertNode(R - i);
\par     InsertNode(R);
\par     Repeat
\par       if (match_length > len) then
\par         match_length := len;
\par       if (match_length <= THRESHOLD) then
\par         begin
\par           match_length := 1;
\par           EncodeChar(Text_buf^[R], PutBytes);
\par         end
\par       else
\par         begin
\par 
\par           EncodeChar(255 - THRESHOLD + match_length, PutBytes);
\par           EncodePosition(match_position, PutBytes);
\par         end;
\par       last_match_length := match_length;
\par       i := 0;
\par       Got := 1;
\par       While (i < last_match_length) and (Got <> 0) do
\par         begin
\par           GetBytes(ct, 1, Got);
\par           if Got <> 0 then
\par             begin
\par               DeleteNode(s);
\par               Text_buf^[s] := ct;
\par               if (s < pred(F)) then
\par                 Text_buf^[s + N] := ct;
\par 
\par               s := succ(s) and pred(N);
\par               R := succ(R) and pred(N);
\par               InsertNode(R);
\par               inc(i);
\par             end;
\par         end;
\par       inc(TextSize, i);
\par       While (i < last_match_length) do
\par         begin
\par           inc(i);
\par           DeleteNode(s);
\par           s := succ(s) and pred(N);
\par           R := succ(R) and pred(N);
\par           dec(len);
\par           if Boolean(len) then InsertNode(R);
\par         end;
\par     Until (len <= 0);
\par     Encodeend(PutBytes);
\par 
\par     endLZH;
\par     Bytes_Written := TextSize;
\par   end;
\par 
\par 
\par   Procedure LZHUnpack(TextSize : LongInt;
\par                       GetBytes : GetBytesProc;
\par                       PutBytes : PutBytesProc);
\par   Var
\par     c, i, j, k, R : Integer;
\par     c2, a : Byte;
\par     count : LongInt;
\par     Put : Word;
\par   begin
\par     InitLZH;
\par     StartHuff;
\par     R := N - F;
\par     fillChar(Text_buf^[0], R, ' ');
\par     count := 0;
\par     While count < TextSize do
\par       begin
\par         c := DecodeChar(GetBytes);
\par 
\par         if (c < 256) then
\par           begin
\par             c2 := lo(c);
\par             PutBytes(c2, 1, Put);
\par             Text_buf^[R] := c;
\par             inc(R);
\par             R := R and pred(N);
\par             inc(count);
\par           end
\par         else
\par           begin
\par             i := (R - succ(DecodePosition(GetBytes))) and pred(N);
\par             j := c - 255 + THRESHOLD;
\par             For k := 0 to pred(j) do
\par               begin
\par                 c := Text_buf^[(i + k) and pred(N)];
\par 
\par                 c2 := lo(c);
\par                 PutBytes(c2, 1, Put);
\par                 Text_buf^[R] := c;
\par                 inc(R);
\par                 R := R and pred(N);
\par                 inc(count);
\par               end;
\par           end;
\par       end;
\par     endLZH;
\par   end;
\par 
\par 
\par end.
\par 
\par _\{
\par > I'm searching for a source code that packs files. The speed should be equal
\par > to LHARC (or fast - why not).
\par 
\par Here is something to pack files useing the same algorithm that LHA uses..
\par \}
\par 
\par unit lzh;
\par 
\par \{$A+,B-,D+,E-,F-,I+,L+,N-,O+,R-,S-,V-\}
\par (*
\par  * LZHUF.C English version 1.0
\par  * Based on Japanese version 29-NOV-1988
\par  * LZSS coded by Haruhiko OKUMURA
\par  * Adaptive Huffman Coding coded by Haruyasu YOSHIZAKI
\par  * Edited and translated to English by Kenji RIKITAKE
\par  * Translated from C to Turbo Pascal by Douglas Webb   2/18/91
\par  *)
\par 
\par \{
\par      This unit allows the user to commpress data using a combination of
\par    LZSS compression and adaptive Huffman coding, or conversely to decompress
\par 
\par    data that was previously compressed by this unit.
\par 
\par      There are a number of options as to where the data being compressed/
\par    decompressed is coming from/going to.
\par 
\par     In fact it requires that you pass the "LZHPack" procedure 2 procedural
\par   parameter of type 'GetProcType' and 'PutProcType' (declared below) which
\par   will accept 3 parameters and act in every way like a 'BlockRead'/'BlockWrite'
\par   procedure call. Your 'GetProcType' procedure should return the data
\par 
\par   to be compressed, and Your 'PutProcType' procedure should do something with
\par   the compressed data (ie., put it in a file).  In case you need to know (and
\par   you do if you want to decompress this data again) the number of bytes in the
\par   compressed data (original, not compressed size) is returned in
\par 'Bytes_Written'.
\par   GetBytesProc = PROCEDURE(VAR DTA; NBytes:WORD; VAR Bytes_Got : WORD);
\par 
\par   DTA is the start of a memory location where the information returned should
\par   be.  NBytes is the number of bytes requested.  The actual number of bytes
\par 
\par   returned must be passed in Bytes_Got (if there is no more data then 0
\par   should be returned).
\par 
\par   PutBytesProc = PROCEDURE(VAR DTA; NBytes:WORD; VAR Bytes_Got : WORD);
\par 
\par   As above except instead of asking for data the procedure is dumping out
\par   compressed data, do somthing with it.
\par 
\par 
\par     "LZHUnPack" is basically the same thing in reverse.  It requires
\par   procedural parameters of type 'PutProcType'/'GetProcType' which
\par   will act as above.  'GetProcType' must retrieve data compressed using
\par 
\par   "LZHPack" (above) and feed it to the unpacking routine as requested.
\par   'PutProcType' must accept the decompressed data and do something
\par   withit.  You must also pass in the original size of the decompressed data,
\par   failure to do so will have adverse results.
\par 
\par 
\par      Don't forget that as procedural parameters the 'GetProcType'/'PutProcType'
\par   procedures must be compiled in the 'F+' state to avoid a catastrophe.
\par 
\par 
\par 
\par \}
\par 
\par \{ Note: All the large data structures for these routines are allocated when
\par 
\par   needed from the heap, and deallocated when finished.  So when not in use
\par   memory requirements are minimal.  However, this unit uses about 34K of
\par   heap space, and 400 bytes of stack when in use. \}
\par 
\par 
\par interface
\par 
\par TYPE
\par 
\par 
\par   PutBytesProc = PROCEDURE(VAR DTA; NBytes:WORD; VAR Bytes_Put : WORD);
\par   GetBytesProc = PROCEDURE(VAR DTA; NBytes:WORD; VAR Bytes_Got : WORD);
\par 
\par 
\par 
\par Procedure LZHPack(VAR Bytes_Written:LongInt; GetBytes:GetBytesProc;
\par PutBytes:PutBytesProc);
\par 
\par 
\par Procedure LZHUnpack(TextSize : Longint;
\par GetBytes:GetBytesProc; PutBytes: PutBytesProc);
\par 
\par 
\par 
\par implementation
\par 
\par CONST
\par   EXIT_OK = 0;
\par   EXIT_FAILED = 1;
\par \{ LZSS Parameters \}
\par   N  = 4096; \{ Size of string buffer \}
\par   F  = 60; \{ Size of look-ahead buffer \}
\par   THRESHOLD = 2;
\par   NUL  = N; \{ End of tree's node  \}
\par   N_CHAR   = (256 - THRESHOLD + F);
\par   \{ character code (:= 0..N_CHAR-1) \}
\par   T     = (N_CHAR * 2 - 1); \{ Size of table \}
\par   R     = (T - 1);  \{ root position \}
\par 
\par   MAX_FREQ = $8000;
\par      \{ update when cumulative frequency \}
\par      \{ reaches to this value \}
\par \{
\par  * Tables FOR encoding/decoding upper 6 bits of
\par  * sliding dictionary pointer
\par  \}
\par \{ encoder table \}
\par   p_len : Array[0..63] of BYTE =
\par        ($03, $04, $04, $04, $05, $05, $05, $05,
\par  $05, $05, $05, $05, $06, $06, $06, $06,
\par  $06, $06, $06, $06, $06, $06, $06, $06,
\par  $07, $07, $07, $07, $07, $07, $07, $07,
\par  $07, $07, $07, $07, $07, $07, $07, $07,
\par  $07, $07, $07, $07, $07, $07, $07, $07,
\par 
\par  $08, $08, $08, $08, $08, $08, $08, $08,
\par  $08, $08, $08, $08, $08, $08, $08, $08);
\par 
\par   p_code : Array [0..63] OF BYTE =
\par        ($00, $20, $30, $40, $50, $58, $60, $68,
\par  $70, $78, $80, $88, $90, $94, $98, $9C,
\par  $A0, $A4, $A8, $AC, $B0, $B4, $B8, $BC,
\par  $C0, $C2, $C4, $C6, $C8, $CA, $CC, $CE,
\par  $D0, $D2, $D4, $D6, $D8, $DA, $DC, $DE,
\par  $E0, $E2, $E4, $E6, $E8, $EA, $EC, $EE,
\par  $F0, $F1, $F2, $F3, $F4, $F5, $F6, $F7,
\par  $F8, $F9, $FA, $FB, $FC, $FD, $FE, $FF);
\par 
\par \{ decoder table \}
\par 
\par   d_code: Array [0..255] OF BYTE =
\par        ($00, $00, $00, $00, $00, $00, $00, $00,
\par  $00, $00, $00, $00, $00, $00, $00, $00,
\par  $00, $00, $00, $00, $00, $00, $00, $00,
\par  $00, $00, $00, $00, $00, $00, $00, $00,
\par  $01, $01, $01, $01, $01, $01, $01, $01,
\par  $01, $01, $01, $01, $01, $01, $01, $01,
\par  $02, $02, $02, $02, $02, $02, $02, $02,
\par  $02, $02, $02, $02, $02, $02, $02, $02,
\par  $03, $03, $03, $03, $03, $03, $03, $03,
\par  $03, $03, $03, $03, $03, $03, $03, $03,
\par  $04, $04, $04, $04, $04, $04, $04, $04,
\par 
\par  $05, $05, $05, $05, $05, $05, $05, $05,
\par  $06, $06, $06, $06, $06, $06, $06, $06,
\par  $07, $07, $07, $07, $07, $07, $07, $07,
\par  $08, $08, $08, $08, $08, $08, $08, $08,
\par  $09, $09, $09, $09, $09, $09, $09, $09,
\par  $0A, $0A, $0A, $0A, $0A, $0A, $0A, $0A,
\par  $0B, $0B, $0B, $0B, $0B, $0B, $0B, $0B,
\par  $0C, $0C, $0C, $0C, $0D, $0D, $0D, $0D,
\par  $0E, $0E, $0E, $0E, $0F, $0F, $0F, $0F,
\par  $10, $10, $10, $10, $11, $11, $11, $11,
\par  $12, $12, $12, $12, $13, $13, $13, $13,
\par  $14, $14, $14, $14, $15, $15, $15, $15,
\par 
\par  $16, $16, $16, $16, $17, $17, $17, $17,
\par  $18, $18, $19, $19, $1A, $1A, $1B, $1B,
\par  $1C, $1C, $1D, $1D, $1E, $1E, $1F, $1F,
\par  $20, $20, $21, $21, $22, $22, $23, $23,
\par  $24, $24, $25, $25, $26, $26, $27, $27,
\par  $28, $28, $29, $29, $2A, $2A, $2B, $2B,
\par  $2C, $2C, $2D, $2D, $2E, $2E, $2F, $2F,
\par  $30, $31, $32, $33, $34, $35, $36, $37,
\par  $38, $39, $3A, $3B, $3C, $3D, $3E, $3F);
\par 
\par  d_len: Array[0..255] of BYTE =
\par        ($03, $03, $03, $03, $03, $03, $03, $03,
\par  $03, $03, $03, $03, $03, $03, $03, $03,
\par 
\par  $03, $03, $03, $03, $03, $03, $03, $03,
\par  $03, $03, $03, $03, $03, $03, $03, $03,
\par  $04, $04, $04, $04, $04, $04, $04, $04,
\par  $04, $04, $04, $04, $04, $04, $04, $04,
\par  $04, $04, $04, $04, $04, $04, $04, $04,
\par  $04, $04, $04, $04, $04, $04, $04, $04,
\par  $04, $04, $04, $04, $04, $04, $04, $04,
\par  $04, $04, $04, $04, $04, $04, $04, $04,
\par  $05, $05, $05, $05, $05, $05, $05, $05,
\par  $05, $05, $05, $05, $05, $05, $05, $05,
\par  $05, $05, $05, $05, $05, $05, $05, $05,
\par  $05, $05, $05, $05, $05, $05, $05, $05,
\par 
\par  $05, $05, $05, $05, $05, $05, $05, $05,
\par  $05, $05, $05, $05, $05, $05, $05, $05,
\par  $05, $05, $05, $05, $05, $05, $05, $05,
\par  $05, $05, $05, $05, $05, $05, $05, $05,
\par  $06, $06, $06, $06, $06, $06, $06, $06,
\par  $06, $06, $06, $06, $06, $06, $06, $06,
\par  $06, $06, $06, $06, $06, $06, $06, $06,
\par  $06, $06, $06, $06, $06, $06, $06, $06,
\par  $06, $06, $06, $06, $06, $06, $06, $06,
\par  $06, $06, $06, $06, $06, $06, $06, $06,
\par  $07, $07, $07, $07, $07, $07, $07, $07,
\par  $07, $07, $07, $07, $07, $07, $07, $07,
\par 
\par  $07, $07, $07, $07, $07, $07, $07, $07,
\par  $07, $07, $07, $07, $07, $07, $07, $07,
\par  $07, $07, $07, $07, $07, $07, $07, $07,
\par  $07, $07, $07, $07, $07, $07, $07, $07,
\par  $08, $08, $08, $08, $08, $08, $08, $08,
\par  $08, $08, $08, $08, $08, $08, $08, $08);
\par 
\par   getbuf : WORD = 0;
\par   getlen : BYTE = 0;
\par   putlen : BYTE = 0;
\par   putbuf : WORD = 0;
\par   textsize : longint = 0;
\par   codesize : longINT = 0;
\par   printcount : longint = 0;
\par   match_position : Integer = 0;
\par   match_length : Integer = 0;
\par 
\par TYPE
\par   Freqtype = Array[0..T] OF WORD;
\par   FreqPtr = ^freqtype;
\par   PntrType = Array[0..T+N_Char] OF Integer;
\par   pntrPtr = ^pntrType;
\par   SonType = Array[0..T] OF Integer;
\par   SonPtr = ^SonType;
\par 
\par 
\par   TextBufType = Array[0..N+F-1] OF BYTE;
\par   TBufPtr = ^TextBufType;
\par   WordRay = Array[0..N+1] OF Integer;
\par   WordRayPtr = ^WordRay;
\par   BWordRay = Array[0..N+257] OF Integer;
\par   BWordRayPtr = ^BWordRay;
\par 
\par VAR
\par   text_buf : TBufPtr;
\par   lson,dad : WordRayPtr;
\par   rson : BWordRayPtr;
\par 
\par   freq : FreqPtr; \{ cumulative freq table \}
\par 
\par \{
\par  * pointing parent nodes.
\par  * area [T..(T + N_CHAR - 1)] are pointers FOR leaves
\par  \}
\par   prnt : PntrPtr;
\par 
\par \{ pointing children nodes (son[], son[] + 1)\}
\par   son : SonPtr;
\par 
\par 
\par 
\par Procedure InitTree;  \{ Initializing tree \}
\par 
\par VAR
\par   i : integer;
\par BEGIN
\par   FOR i := N + 1 TO N + 256 DO
\par  rson^[i] := NUL;   \{ root \}
\par   FOR i := 0 TO N DO
\par  dad^[i] := NUL;   \{ node \}
\par END;
\par 
\par 
\par 
\par 
\par 
\par Procedure InsertNode(r : Integer);  \{ Inserting node to the tree \}
\par 
\par VAR
\par   tmp,i, p, cmp : Integer;
\par   key : TBufPtr;
\par   c : WORD;
\par 
\par BEGIN
\par      cmp := 1;
\par      key := @text_buf^[r];
\par      p := SUCC(N) + key^[0];
\par      rson^[r] := NUL;
\par      lson^[r] := NUL;
\par      match_length := 0;
\par      WHILE match_length < F DO
\par        BEGIN
\par          IF (cmp >= 0) THEN
\par            BEGIN
\par       IF (rson^[p] <> NUL) THEN
\par         p := rson^[p]
\par       ELSE
\par                BEGIN
\par           rson^[p] := r;
\par    dad^[r] := p;
\par    exit;
\par         END;
\par     END
\par 
\par          ELSE
\par            BEGIN
\par       IF (lson^[p] <> NUL) THEN
\par         p := lson^[p]
\par       ELSE
\par                BEGIN
\par           lson^[p] := r;
\par    dad^[r] := p;
\par    exit;
\par         END;
\par     END;
\par          i := 0;
\par          cmp := 0;
\par   While (i < F) AND (cmp = 0) DO
\par            BEGIN
\par              inc(i);
\par              cmp := key^[i] - text_buf^[p + i];
\par            END;
\par          IF (i > THRESHOLD) THEN
\par            BEGIN
\par              tmp := PRED((r - p) AND PRED(N));
\par 
\par       IF (i > match_length) THEN
\par                BEGIN
\par           match_position := tmp;
\par                  match_length := i;
\par         END;
\par       IF (match_length < F) AND (i = match_length) THEN
\par                BEGIN
\par                  c := tmp;
\par    IF (c < match_position) THEN
\par                    match_position := c;
\par         END;
\par     END;
\par        END;                \{ WHILE TRUE DO \}
\par      dad^[r] := dad^[p];
\par      lson^[r] := lson^[p];
\par      rson^[r] := rson^[p];
\par      dad^[lson^[p]] := r;
\par 
\par      dad^[rson^[p]] := r;
\par      IF (rson^[dad^[p]] = p) THEN
\par        rson^[dad^[p]] := r
\par      ELSE
\par        lson^[dad^[p]] := r;
\par      dad^[p] := NUL;  \{ remove p \}
\par END;
\par 
\par 
\par 
\par 
\par Procedure DeleteNode(p: Integer);  \{ Deleting node from the tree \}
\par 
\par VAR
\par   q : Integer;
\par 
\par BEGIN
\par   IF (dad^[p] = NUL) THEN
\par     exit;   \{ unregistered \}
\par   IF (rson^[p] = NUL) THEN
\par     q := lson^[p]
\par   ELSE IF (lson^[p] = NUL) THEN
\par     q := rson^[p]
\par   ELSE
\par     BEGIN
\par       q := lson^[p];
\par 
\par       IF (rson^[q] <> NUL) THEN
\par         BEGIN
\par    REPEAT
\par             q := rson^[q];
\par    UNTIL (rson^[q] = NUL);
\par           rson^[dad^[q]] := lson^[q];
\par    dad^[lson^[q]] := dad^[q];
\par    lson^[q] := lson^[p];
\par    dad^[lson^[p]] := q;
\par  END;
\par       rson^[q] := rson^[p];
\par       dad^[rson^[p]] := q;
\par     END;
\par   dad^[q] := dad^[p];
\par   IF (rson^[dad^[p]] = p) THEN
\par     rson^[dad^[p]] := q
\par   ELSE
\par     lson^[dad^[p]] := q;
\par   dad^[p] := NUL;
\par END;
\par 
\par 
\par \{ Huffman coding parameters \}
\par 
\par Function GetBit(GetBytes:GetBytesProc): Integer; \{ get one bit \}
\par VAR
\par   i: BYTE;
\par   i2 : Integer;
\par   result : Word;
\par 
\par BEGIN
\par   WHILE (getlen <= 8) DO
\par     BEGIN
\par       GetBytes(i,1,Result);
\par       If Result = 1 THEN
\par         i2 := i
\par       ELSE i2 := 0;
\par       getbuf := getbuf OR (i2 SHL (8 - getlen));
\par       INC(getlen,8);
\par     END;
\par   i2 := getbuf;
\par   getbuf := getbuf SHL 1;
\par   DEC(getlen);
\par   getbit := INTEGER((i2 < 0));
\par END;
\par 
\par 
\par 
\par 
\par Function GetByte(GetBytes:GetBytesProc): Integer; \{ get a byte \}
\par 
\par VAR
\par   j : BYTE;
\par   i,result : WORD;
\par BEGIN
\par   WHILE (getlen <= 8) DO
\par     BEGIN
\par       GetBytes(j,1,result);
\par       If Result = 1 THEN
\par         i := j
\par       ELSE
\par         i := 0;
\par       getbuf := getbuf OR (i SHL (8 - getlen));
\par       INC(getlen,8);
\par     END;
\par   i := getbuf;
\par   getbuf := getbuf SHL 8;
\par   DEC(getlen,8);
\par   getbyte := integer(i SHR 8);
\par END;
\par 
\par PROCEDURE Putcode(l : Integer; c: WORD;PutBytes:PutBytesProc);  \{ output c bits
\par \}VAR
\par   Temp : BYTE;
\par   Got : WORD;
\par 
\par BEGIN
\par   putbuf := putbuf OR (c SHR putlen);
\par   inc(putlen,l);
\par   IF (putlen >= 8) THEN
\par     BEGIN
\par       Temp := putbuf SHR 8;
\par       PutBytes(Temp,1,Got);
\par       DEC(putlen,8);
\par       IF (putlen  >= 8) THEN
\par         BEGIN
\par           Temp := Lo(PutBuf);
\par    PutBytes(Temp,1,Got);
\par    INC(codesize,2);
\par    DEC(putlen,8);
\par    putbuf := c SHL (l - putlen);
\par  END
\par       ELSE
\par         BEGIN
\par    putbuf := putbuf SHL 8;
\par    INC(codesize);
\par  END;
\par     END;
\par END;
\par 
\par 
\par 
\par \{ initialize freq tree \}
\par 
\par Procedure StartHuff;
\par VAR
\par   i, j : Integer;
\par BEGIN
\par   FOR i := 0 to PRED(N_CHAR) DO
\par     BEGIN
\par       freq^[i] := 1;
\par       son^[i] := i + T;
\par       prnt^[i + T] := i;
\par     END;
\par   i := 0;
\par   j := N_CHAR;
\par   WHILE (j <= R) DO
\par     BEGIN
\par       freq^[j] := freq^[i] + freq^[i + 1];
\par       son^[j] := i;
\par       prnt^[i] := j;
\par       prnt^[i + 1] := j;
\par       INC(i,2);
\par       INC(j);
\par     END;
\par   freq^[T] := $ffff;
\par   prnt^[R] := 0;
\par END;
\par 
\par 
\par 
\par 
\par \{ reconstruct freq tree \}
\par 
\par PROCEDURE reconst;
\par VAR
\par  i, j, k, tmp : Integer;
\par  f, l : WORD;
\par BEGIN
\par  \{ halven cumulative freq FOR leaf nodes \}
\par   j := 0;
\par   FOR i := 0 to PRED(T) DO
\par     BEGIN
\par       IF (son^[i] >= T) THEN
\par         BEGIN
\par    freq^[j] := SUCC(freq^[i]) MOD 2;
\par    son^[j] := son^[i];
\par    INC(j);
\par  END;
\par     END;
\par   \{ make a tree : first, connect children nodes \}
\par   i := 0;
\par   j := N_CHAR;
\par   WHILE (j < T) DO
\par     BEGIN
\par       k := SUCC(i);
\par       f := freq^[i] + freq^[k];
\par       freq^[j] := f;
\par 
\par       k := PRED(j);
\par       WHILE f < freq^[k] DO
\par         DEC(K);
\par       INC(k);
\par       l := (j - k) SHL 1;
\par       tmp := SUCC(k);
\par       move(freq^[k], freq^[tmp], l);
\par       freq^[k] := f;
\par       move(son^[k], son^[tmp], l);
\par       son^[k] := i;
\par       INC(i,2);
\par       INC(j);
\par     END;
\par      \{ connect parent nodes \}
\par   FOR i := 0 to PRED(T) DO
\par     BEGIN
\par       k := son^[i];
\par       IF (k >= T) THEN
\par         BEGIN
\par    prnt^[k] := i;
\par  END
\par       ELSE
\par         BEGIN
\par    prnt^[k] := i;
\par 
\par           prnt^[SUCC(k)] := i;
\par  END;
\par     END;
\par END;
\par 
\par 
\par \{ update freq tree \}
\par 
\par Procedure update(c : Integer);
\par VAR
\par   i, j, k, l : Integer;
\par BEGIN
\par   IF (freq^[R] = MAX_FREQ) THEN
\par     BEGIN
\par       reconst;
\par     END;
\par   c := prnt^[c + T];
\par   REPEAT
\par     INC(freq^[c]);
\par     k := freq^[c];
\par 
\par  \{ swap nodes to keep the tree freq-ordered \}
\par    l := SUCC(C);
\par    IF (k > freq^[l]) THEN
\par      BEGIN
\par        WHILE (k > freq^[l]) DO
\par          INC(l);
\par        DEC(l);
\par        freq^[c] := freq^[l];
\par 
\par        freq^[l] := k;
\par 
\par        i := son^[c];
\par        prnt^[i] := l;
\par        IF (i < T) THEN prnt^[SUCC(i)] := l;
\par 
\par        j := son^[l];
\par        son^[l] := i;
\par 
\par        prnt^[j] := c;
\par        IF (j < T) THEN prnt^[SUCC(j)] := c;
\par        son^[c] := j;
\par 
\par        c := l;
\par      END;
\par    c := prnt^[c];
\par  UNTIL (c = 0); \{ REPEAT it until reaching the root \}
\par END;
\par 
\par 
\par VAR
\par   code, len : WORD;
\par 
\par 
\par 
\par 
\par PROCEDURE EncodeChar(c: WORD;PutBytes:PutBytesProc);
\par VAR
\par   i : WORD;
\par   j, k : Integer;
\par 
\par BEGIN
\par   i := 0;
\par   j := 0;
\par   k := prnt^[c + T];
\par 
\par  \{ search connections from leaf node to the root \}
\par   REPEAT
\par     i := i SHR 1;
\par 
\par  \{
\par  IF node's address is odd, output 1
\par  ELSE output 0
\par  \}
\par     IF BOOLEAN(k AND 1) THEN INC(i,$8000);
\par     INC(j);
\par     k := prnt^[k];
\par   UNTIL (k = R);
\par   Putcode(j, i,PutBytes);
\par   code := i;
\par   len := j;
\par   update(c);
\par END;
\par 
\par 
\par 
\par Procedure EncodePosition(c : WORD;PutBytes:PutBytesProc);
\par VAR
\par   i,j : WORD;
\par BEGIN
\par  \{ output upper 6 bits with encoding \}
\par 
\par   i := c SHR 6;
\par   j := p_code[i];
\par   Putcode(p_len[i],j SHL 8,PutBytes);
\par 
\par  \{ output lower 6 bits directly \}
\par   Putcode(6, (c AND $3f) SHL 10,PutBytes);
\par END;
\par 
\par 
\par 
\par Procedure EncodeEnd(PutBytes:PutBytesProc);
\par VAR
\par   Temp : BYTE;
\par   Got : WORD;
\par BEGIN
\par   IF BOOLEAN(putlen) THEN
\par     BEGIN
\par       Temp := Lo(putbuf SHR 8);
\par       PutBytes(Temp,1,Got);
\par       INC(codesize);
\par     END;
\par END;
\par 
\par 
\par 
\par 
\par 
\par FUNCTION DecodeChar(GetBytes:GetBytesProc): Integer;
\par VAR
\par   c : WORD;
\par BEGIN
\par 
\par   c := son^[R];
\par 
\par     \{
\par      * start searching tree from the root to leaves.
\par      * choose node #(son[]) IF input bit = 0
\par      * ELSE choose #(son[]+1) (input bit = 1)
\par     \}
\par   WHILE (c < T) DO
\par     BEGIN
\par       c := c + GetBit(GetBytes);
\par       c := son^[c];
\par     END;
\par   c := c - T;
\par   update(c);
\par   Decodechar := Integer(c);
\par END;
\par 
\par 
\par 
\par 
\par 
\par Function DecodePosition(GetBytes:GetBytesProc) : WORD;
\par VAR
\par   i, j, c : WORD;
\par BEGIN
\par      \{ decode upper 6 bits from given table \}
\par 
\par   i := GetByte(GetBytes);
\par   c := WORD(d_code[i] SHL 6);
\par   j := d_len[i];
\par 
\par  \{ input lower 6 bits directly \}
\par   DEC(j,2);
\par   While j <> 0 DO
\par     BEGIN
\par       i := (i SHL 1) + GetBit(GetBytes);
\par       DEC(J);
\par     END;
\par   DecodePosition := c OR i AND $3f;
\par END;
\par 
\par 
\par 
\par \{ Compression \}
\par 
\par 
\par 
\par Procedure InitLZH;
\par BEGIN
\par   getbuf := 0;
\par   getlen := 0;
\par   putlen := 0;
\par   putbuf := 0;
\par   textsize := 0;
\par   codesize := 0;
\par   printcount := 0;
\par   match_position := 0;
\par   match_length := 0;
\par 
\par   New(lson);
\par   New(dad);
\par   New(rson);
\par   New(text_buf);
\par   New(freq);
\par   New(prnt);
\par   New(son);
\par END;
\par 
\par 
\par Procedure EndLZH;
\par 
\par BEGIN
\par   Dispose(son);
\par   Dispose(prnt);
\par   Dispose(freq);
\par   Dispose(text_buf);
\par   Dispose(rson);
\par   Dispose(dad);
\par   Dispose(lson);
\par END;
\par 
\par 
\par Procedure LZHPack(VAR Bytes_Written:LongInt; GetBytes:GetBytesProc;
\par PutBytes:PutBytesProc);VAR
\par    ct : BYTE;
\par    i, len, r, s, last_match_length : Integer;
\par    Got : WORD;
\par BEGIN
\par   InitLZH;
\par 
\par   textsize := 0;   \{ rewind and rescan \}
\par 
\par   StartHuff;
\par   InitTree;
\par   s := 0;
\par   r := N - F;
\par   FillChar(Text_buf^[0],r,' ');
\par   len := 0;
\par   Got := 1;
\par   While (len < F) AND (Got <> 0) DO
\par     BEGIN
\par       GetBytes(ct,1,Got);
\par       IF Got <> 0 THEN
\par         BEGIN
\par           text_buf^[r + len] := ct;
\par           INC(len);
\par         END;
\par     END;
\par   textsize := len;
\par   FOR i := 1 to F DO
\par     InsertNode(r - i);
\par   InsertNode(r);
\par   REPEAT
\par     IF (match_length > len) THEN
\par       match_length := len;
\par     IF (match_length <= THRESHOLD) THEN
\par 
\par       BEGIN
\par         match_length := 1;
\par  EncodeChar(text_buf^[r],PutBytes);
\par       END
\par     ELSE
\par       BEGIN
\par         EncodeChar(255 - THRESHOLD + match_length,PutBytes);
\par  EncodePosition(match_position,PutBytes);
\par       END;
\par     last_match_length := match_length;
\par     i := 0;
\par     Got := 1;
\par     While (i < last_match_length) AND (Got <> 0) DO
\par       BEGIN
\par         GetBytes(ct,1,Got);
\par         IF Got <> 0 THEN
\par           BEGIN
\par             DeleteNode(s);
\par      text_buf^[s] := ct;
\par 
\par        IF (s < PRED(F)) THEN
\par        text_buf^[s + N] := ct;
\par      s := SUCC(s) AND PRED(N);
\par      r := SUCC(r) AND PRED(N);
\par      InsertNode(r);
\par             inc(i);
\par           END;
\par       END;
\par     INC(textsize,i);
\par     While (i < last_match_length) DO
\par       BEGIN
\par         INC(i);
\par         DeleteNode(s);
\par         s := SUCC(s) AND PRED(N);
\par         r := SUCC(r) AND PRED(N);
\par         DEC(len);
\par         IF BOOLEAN(len) THEN InsertNode(r);
\par       END;
\par   UNTIL (len <= 0);
\par 
\par   EncodeEnd(PutBytes);
\par   EndLZH;
\par   Bytes_Written := TextSize;
\par END;
\par 
\par 
\par 
\par 
\par Procedure LZHUnpack(TextSize : Longint; GetBytes:GetBytesProc; PutBytes:
\par PutBytesProc);VAR
\par   c, i, j, k, r : Integer;
\par   c2,a : Byte;
\par   count : Longint;
\par   Put : Word;
\par 
\par BEGIN
\par   InitLZH;
\par   StartHuff;
\par   r := N - F;
\par   FillChar(text_buf^[0],r,' ');
\par   Count := 0;
\par   While count < textsize DO
\par     BEGIN
\par       c := DecodeChar(GetBytes);
\par       IF (c < 256) THEN
\par         BEGIN
\par           c2 := Lo(c);
\par 
\par    PutBytes(c2,1,Put);
\par    text_buf^[r] := c;
\par           INC(r);
\par    r := r AND PRED(N);
\par    INC(count);
\par  END
\par       ELSE
\par         BEGIN
\par    i := (r - SUCC(DecodePosition(GetBytes))) AND PRED(N);
\par    j := c - 255 + THRESHOLD;
\par    FOR k := 0 TO PRED(j) DO
\par             BEGIN
\par        c := text_buf^[(i + k) AND PRED(N)];
\par               c2 := Lo(c);
\par        PutBytes(c2,1,Put);
\par        text_buf^[r] := c;
\par               INC(r);
\par        r := r AND PRED(N);
\par        INC(count);
\par      END;
\par 
\par  END;
\par     END;
\par   ENDLZH;
\par END;
\par 
\par 
\par END.
\par 
\par \{
\par Thought you should know there are two versions of that code.  The first one
\par had a critical bug in it somewhere.  Sorry, don't have time to elaborate.  If
\par this is the re-released version then it's alright.  Interestingly, a company
\par markets this compiled code as part of their "program Installer" product.  See
\par below too.  They use a DLL implementation.  Here is the README.TXT from the
\par correct version (MAY 1, 1991):
\par 
\par \plain\f3\fs20\cf3 **************************************************************************************************************************\plain\f3\fs20\cf0 
\par 
\par What I have done is transcribe the LZHUF algorithm into Turbo pascal.
\par LZH.PAS is the source code for a fairly flexible unit which can compress and
\par decompress any kind of data you throw at it.  LZHTEST.PAS is a sample program
\par which can compress/decompress one file at a time.
\par   What you see is what you get - little documentation, moderate performance
\par (be charitable, please), and it's free.  Enjoy.
\par 
\par  There was a bug in the first version I made available in February which
\par 
\par caused the unit to hang if it was called upon to compress a large amount
\par of data. I have fixed this one bug and it now seems to work correctly.
\par I apologize for any lost sleep this may have caused.
\par \}
\par _____________________________________________________________
\par \{lzhtest.pas\}
\par 
\par Program LZHTest;
\par Uses
\par   LZH;
\par 
\par Const
\par   MaxBuf = 4096;                       \{ Must be bigger than the biggest chunk being asked For. \}
\par 
\par Type
\par   BufType = Array[1..MaxBuf] of Byte;
\par 
\par   BufPtr = ^BufType;
\par 
\par Var
\par   InBuf, OutBuf : BufPtr;
\par   inFile, OutFile : File;
\par   s : String;
\par   Bytes_Written : LongInt;
\par   Size : LongInt;
\par   Temp : Word;
\par 
\par 
\par   \{$F+\}
\par   Procedure GetBlock(Var Target; NoBytes : Word; Var Actual_Bytes : Word);
\par   Const
\par     Posn : Word = 1;
\par     Buf : Word = 0;
\par   Var
\par     Temp : Word;
\par   begin
\par     if (Posn > Buf) or (Posn + NoBytes > succ(Buf)) then
\par       begin
\par         if Posn > Buf then
\par           begin
\par             blockread(inFile, InBuf^, MaxBuf, Buf);
\par 
\par             Write('+');
\par           end
\par         else
\par           begin
\par             move(InBuf^[Posn], InBuf^[1], Buf - Posn);
\par             blockread(inFile, InBuf^[Buf - Posn], MaxBuf - (Buf - Posn), Temp);
\par             Buf := Buf - Posn + Temp;
\par             Write('+');
\par           end;
\par         if Buf = 0 then
\par           begin
\par             Actual_Bytes := 0;
\par             Writeln;
\par             Exit;
\par           end;
\par         Posn := 1;
\par       end;
\par     move(InBuf^[Posn], Target, NoBytes);
\par 
\par     inc(Posn, NoBytes);
\par     if Posn > succ(Buf) then
\par       Actual_Bytes := NoBytes - (Posn - succ(Buf))
\par     else Actual_Bytes := NoBytes;
\par   end;
\par 
\par 
\par   Procedure PutBlock(Var Source; NoBytes : Word; Var Actual_Bytes : Word);
\par   Const
\par     Posn : Word = 1;
\par   Var
\par     Temp : Word;
\par   begin
\par     if NoBytes = 0 then                \{ Flush condition \}
\par       begin
\par         blockWrite(OutFile, OutBuf^, pred(Posn), Temp);
\par         Exit;
\par       end;
\par     if (Posn > MaxBuf) or (Posn + NoBytes > succ(MaxBuf)) then
\par 
\par       begin
\par         blockWrite(OutFile, OutBuf^, pred(Posn), Temp);
\par         Posn := 1;
\par       end;
\par     move(Source, OutBuf^[Posn], NoBytes);
\par     inc(Posn, NoBytes);
\par     Actual_Bytes := NoBytes;
\par   end;
\par 
\par   \{$F-\}
\par 
\par begin
\par   if (paramcount <> 3) then
\par     begin
\par       Writeln('Usage:lzhuf e(Compression)|d(unCompression) inFile outFile');
\par       halt(1);
\par     end;
\par   s := paramstr(1);
\par   if not(s[1] in ['D', 'E', 'd', 'e']) then
\par     halt(1);
\par   assign(inFile, paramstr(2));
\par 
\par   reset(inFile, 1);
\par   assign(OutFile, paramstr(3));
\par   reWrite(OutFile, 1);
\par   new(InBuf);
\par   new(OutBuf);
\par   if (upCase(s[1]) = 'E') then
\par     begin
\par       Size := Filesize(inFile);
\par       blockWrite(OutFile, Size, sizeof(LongInt));
\par       LZHPack(Bytes_Written, GetBlock, PutBlock);
\par       PutBlock(Size, 0, Temp);
\par     end
\par   else
\par     begin
\par       blockread(inFile, Size, sizeof(LongInt));
\par       LZHUnPack(Size, GetBlock, PutBlock);
\par       PutBlock(Size, 0, Temp);
\par     end;
\par 
\par   dispose(OutBuf);
\par   dispose(InBuf);
\par   close(inFile);
\par   close(OutFile);
\par end.\plain\f3\fs20 
\par }
270
Scribble270
Gepackte Dateien
ARJ;Komprimieralgorithmen;Komprimierung;laufzeitkomprimierte Dateien;LHA;PKLITE;PKZIP;UNP;ZOO;


b:000180
Writing



FALSE
32
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fcharset1 Arial;}{\f4\fswiss\fprq2 System;}}
{\colortbl\red0\green0\blue0;\red0\green128\blue0;\red128\green0\blue0;\red0\green0\blue255;}
\deflang1031\pard\plain\f3\fs32\cf3\b Gepackte Dateien\plain\f3\fs32\cf2\b \{keepn\}\plain\f3\fs32\cf3\b 
\par \plain\f3\fs20\cf0\b Laufzeitkomprimierte Dateien:\plain\f3\fs20\cf0 
\par Diese Dateien sind ganz normale *.exe oder *.com-Dateien, die ganz normal ausgef\'fchrt werden, aber nicht ganz normal sind, da sie w\'e4hrend der Laufzeit erst entpackt werden und im normalen Zustand komprimiert vorliegen. Sollten Sie mit Pa\'dfwort komprimiert sein, so erh\'e4lt man den Code am besten mit einem \plain\f3\fs20\cf1\ul Parameterdummy\plain\f3\fs20\cf2 \{linkID=275\}\plain\f3\fs20\cf0 . Entpackt werden diese Dateien mit dem Packprogramm selber oder mit einem Universalprogramm wie "UNP" von Ben Castricum. Sind Sie einmal in normaler Form, so sind es \plain\f3\fs20\cf1\strike ausf\'fchrbare Dateien\plain\f3\fs20\cf2 \{linkID=280\}\plain\f3\fs20\cf0 . Allgemein erkennt man diese Dateien, da\'df sie fast keinen normalen Text enthalten.
\par 
\par \pard\tx200\plain\f3\fs20\cf0 PKLite(exe):
\par \pard\plain\f3\fs20\cf0 "PKLITE" in der 2. Zeile
\par 
\par \pard\tx200\plain\f3\fs20\cf0 Tinyprog(exe):
\par \pard\plain\f3\fs20\cf0 "TZ" in der Zeile nach dem Copyrighttext
\par \plain\f3\fs20\cf0\b 
\par Archive:
\par \plain\f3\fs20\cf0 Archive k\'f6nnen selbstentpackend sein oder sie werden \'fcber ein Hilfsprogramm entpackt. Auf jeden Fall erkennt man Sie daran, da\'df am Anfang(Dateikopf) mindestens ein Dateiname vermerkt ist. Sollten Sie verschl\'fcsselt sein, so kann man u.U. den \plain\f3\fs20\cf1\ul Parameterdummy\plain\f3\fs20\cf2 \{linkID=275\}\plain\f3\fs20\cf0  wieder anwenden.
\par 
\par \pard\tx200\plain\f3\fs20\cf0 ARJ(exe, arj):
\par \pard\plain\f3\fs20\cf0 "RJSX" in der 1. Zeile bei selbstentpackenden Archiven
\par der Archivname steht in der 1.Zeile
\par 
\par Lharc(exe, arc):
\par "LHAs SFX ..... (c) Yoshi.." in der 1. Zeile 
\par das Zeichen $1A steht an erster Stelle
\par 
\par Microsoft (R) File Compression Utility(??_):
\par am Anfang steht "SZDD"
\par 
\par PKZIP(zip):
\par "PK" sind die ersten beiden Zeichen
\par 
\par ZOO(zoo):
\par "ZOO" sind die ersten drei Zeichen\plain\f3\fs20 
\par }
275
Scribble275
Parameterdummy




Writing



FALSE
8
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fprq2 System;}{\f4\fswiss\fcharset1 Arial;}}
{\colortbl\red0\green0\blue0;\red0\green0\blue255;\red128\green0\blue0;}
\deflang1031\pard\plain\f2\fs20\cf0 Ein Parameterdummy zeigt alle Parameter an, mit denen er aufgerufen wurde. So zeigt er auch Pa\'dfw\'f6rter an, die als Parameter beim Aufruf eines Programms gesetzt werden. Den folgenden Quelltext kompilieren Sie mit einem Pascalcompiler und benennen die entstehende "*.exe"-Datei in die gew\'fcnschte Datei um.\plain\f2\fs20\cf2 \{keepn\}\plain\f2\fs20\cf0 
\par \plain\f2\fs32\cf1\b 
\par \plain\f2\fs20 
\par 
\par 
\par }
280
Scribble280
Ausführbare Dateien
*.exe;Dateiendung;


b:000190
Writing



FALSE
7
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fprq2 System;}{\f4\fswiss\fcharset1 Arial;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;\red0\green128\blue0;\red0\green0\blue255;}
\deflang1031\pard\plain\f4\fs32\cf3\b Ausf\'fchrbare Dateien\plain\f4\fs32\cf1\b \{keepn\}\plain\f4\fs32\cf3\b 
\par \plain\f4\fs20 F\'fcr ausf\'fchrbare EXE-Dateien (Dateiendung *.exe) ist es charakteristisch, da\'df sie als erste zwei Buchstaben "MZ" besitzen. In vielen Spielen erhalten Dateien, die eigentlich ausf\'fchrbar sind, unpassende Namen wie "sound.dat". Wenn man solche Dateien findet, dringt man mit einer Umbenennung in eine "*.exe"-Datei tiefer in die Funktionalit\'e4t des Programmes ein. EXE-Dateien besitzen einen Dateikopf, der dem Programm die verschiedenen Speichertypen zuweist. Ganz im Gegenteil dazu stehen "*.com"-Dateien, die ausschlie\'dflich aus einer Reihe von Kommandos bestehen. Sie sind sehr schwer von Datendateien zu unterscheiden und eine wahllose Umbenennung aller Programmdateien f\'fchrt in 99% aller F\'e4lle zu einem Rechnerabsturz oder schlimmeren. Deshalb sollte man folgendes beachten: Die meisten Autoren lassen es sich nicht nehmen und schreiben eine Copyrightzeile in ihre ausf\'fchrbare Dateien (oder der Compiler tut es). Wenn man also mit einem \plain\f4\fs20\cf2\ul Textbetrachter\plain\f4\fs20\cf1 \{linkID=285\}\plain\f4\fs20  signifikante W\'f6rtern wie "right", "copy" oder "reserve" findet, so steigt die Wahrscheinlichkeit, da\'df es sich hierbei um eine "*.com"-Datei handelt.
\par 
\par Nat\'fcrlich soll der dritte Dateityp nicht unerw\'e4hnt bleiben: Die Stapelverarbeitungsprogramme mit der Endung "*.bat". Sie erkennt man daran, da\'df in einigen Textzeilen Programme aufgerufen werden oder Kommandos wie "echo" benutzt werden.
\par }
285
Scribble285
Textbetrachter




Writing



FALSE
21
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fprq2 System;}{\f4\fswiss\fcharset1 Arial;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;}
\deflang1031\pard\plain\f2\fs20\cf0 Ein guter Textbetrachter sollte folgendes erm\'f6glichen:
\par \pard\li200\fi-200\tx200{\*\pn\pnlvlblt\pnf1\pnindent200{\pntxtb\'b7}}\plain\f2\fs20\cf0 {\pntext\f1\'b7\tab}
\par {\pntext\f1\'b7\tab} Keine Datenmengenbeschr\'e4nkung
\par {\pntext\f1\'b7\tab} Zeilenumbruch
\par {\pntext\f1\'b7\tab} ANSI/ASCII-Darstellung
\par {\pntext\f1\'b7\tab} Hexadezimalmodus
\par {\pntext\f1\'b7\tab} Suchfunktion mit zahlreichen Optionen:
\par {\pntext\f1\'b7\tab}\tab Gro\'df/Kleinschreibung
\par {\pntext\f1\'b7\tab}\tab separate W\'f6rter/einzelne Buchstaben
\par {\pntext\f1\'b7\tab}\tab Weitersuchen
\par {\pntext\f1\'b7\tab}\tab Jokerzeichen
\par {\pntext\f1\'b7\tab} Drucken
\par {\pntext\f1\'b7\tab} Anzeige von aktueller Zeile/Spalte
\par {\pntext\f1\'b7\tab} Filterfunktion f\'fcr nichtdarstellbare Zeichen
\par {\pntext\f1\'b7\tab} F\'fcr Windows wichtig: der Dateimodus mu\'df immer auf readonly gesetzt werden
\par {\pntext\f1\'b7\tab} alles andere ist nur Ballast
\par \pard\tx200\plain\f2\fs20\cf0 
\par \pard\plain\f2\fs20\cf0 Ein gutes Beispiel bietet wpview von Norton Commander, welches alle Funktionen bis auf die vorletzte mehr oder weniger erf\'fcllt.\plain\f2\fs20\cf1 \{keepn\}\plain\f2\fs20 
\par }
290
Scribble290
Bild- & Videodateien
Bitmap;CompuServe Bitmap;Corel Draw;JPEG;TIFF;Video;Videodateien;Windows Meta File;


b:000200
Writing



FALSE
23
{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fswiss\fcharset1 Arial;}{\f3\fswiss\fprq2 System;}{\f4\fswiss\fcharset1 Arial;}}
{\colortbl\red0\green0\blue0;\red128\green0\blue0;\red0\green0\blue255;}
\deflang1031\pard\plain\f4\fs32\cf2\b Bild- & Videodateien\plain\f4\fs32\cf1\b \{keepn\}\plain\f4\fs20 
\par Es sollen hier nur die wichtigsten Bild- und Videoformate vorgestellt werden:
\par 
\par Bitmap(bmp):
\par "BM" sind die ersten Zeichen
\par 
\par Corel Draw(cdr):
\par "RIFF....CDR" sind die ersten Zeichen
\par 
\par CompuServe Bitmap(gif):
\par "GIF" sind die ersten Zeichen
\par 
\par JPEG(jpg):
\par "JFIF" steht in der ersten Zeile
\par 
\par TIFF(tif):
\par "II" sind die ersten Zeichen
\par 
\par Windows Meta File(wmf):
\par $D7, $CD, $C6, $9A sind die ersten Zeichen
\par }
0
0
0
24
1 CheatLex
2 Was ist CheatLex?=Scribble10
2 Systemvorausetzungen=Scribble20
2 Die Menüs=Scribble30
1 Die Kunst des Cheatens
2 Vorwort=Scribble110
2 Einführung=Scribble120
2 Was brauche ich?=Scribble125
2 Cheats=Scribble130
2 Levelcodes=Scribble140
2 Patches=Scribble150
2 Leveldateien kopieren=Scribble160
2 Bits & Bytes=Scribble180
2 Hexzahlen=Scribble190
2 Offset & Sektor=Scribble200
2 Spielstände manipulieren=Scribble210
2 Theorie der Decodierung=Scribble220
2 Subtraktions/Additions-Codieralgorithmen=Scribble230
2 Bitweise Codierung=Scribble240
2 Komprimierung=Scribble250
2 Der LZH-Algorithmus=Scribble260
2 Gepackte Dateien=Scribble270
2 Ausführbare Dateien=Scribble280
2 Bild- & Videodateien=Scribble290
6
*InternetLink
16711680
Courier New
0
10
1
....
0
0
0
0
0
0
*ParagraphTitle
-2147483640
Arial
0
11
1
B...
0
0
0
0
0
0
*PopupLink
-2147483640
Arial
0
8
1
....
0
0
0
0
0
0
*PopupTopicTitle
16711680
Arial
0
10
1
B...
0
0
0
0
0
0
*TopicText
-2147483640
Arial
0
10
1
....
0
0
0
0
0
0
*TopicTitle
16711680
Arial
0
16
1
B...
0
0
0
0
0
0
